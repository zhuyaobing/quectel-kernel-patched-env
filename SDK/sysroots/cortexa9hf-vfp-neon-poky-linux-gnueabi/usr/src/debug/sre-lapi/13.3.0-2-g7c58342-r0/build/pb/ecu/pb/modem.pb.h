// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: modem.proto

#ifndef PROTOBUF_modem_2eproto__INCLUDED
#define PROTOBUF_modem_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace ecu {
namespace lapi {
namespace pb {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_modem_2eproto();
void protobuf_AssignDesc_modem_2eproto();
void protobuf_ShutdownFile_modem_2eproto();

class ModemSim;
class ModemSimInformation;
class ModemHardware;
class ModemRegistration;
class ModemLocation;
class ModemStatus;
class ModemSms;

enum ModemRegistration_RegistrationStatus {
  ModemRegistration_RegistrationStatus_RS_NOT_SET = 0,
  ModemRegistration_RegistrationStatus_RS_NOTREG = 1,
  ModemRegistration_RegistrationStatus_RS_HOME = 2,
  ModemRegistration_RegistrationStatus_RS_SEARCH = 3,
  ModemRegistration_RegistrationStatus_RS_DENIED = 4,
  ModemRegistration_RegistrationStatus_RS_UNKNOWN = 5,
  ModemRegistration_RegistrationStatus_RS_ROAMING = 6,
  ModemRegistration_RegistrationStatus_RS_SMSHOME = 7,
  ModemRegistration_RegistrationStatus_RS_SMSROAM = 8,
  ModemRegistration_RegistrationStatus_RS_EMERGENCY = 9,
  ModemRegistration_RegistrationStatus_RS_NCSFBHOME = 10,
  ModemRegistration_RegistrationStatus_RS_NCSFBROAM = 11
};
bool ModemRegistration_RegistrationStatus_IsValid(int value);
const ModemRegistration_RegistrationStatus ModemRegistration_RegistrationStatus_RegistrationStatus_MIN = ModemRegistration_RegistrationStatus_RS_NOT_SET;
const ModemRegistration_RegistrationStatus ModemRegistration_RegistrationStatus_RegistrationStatus_MAX = ModemRegistration_RegistrationStatus_RS_NCSFBROAM;
const int ModemRegistration_RegistrationStatus_RegistrationStatus_ARRAYSIZE = ModemRegistration_RegistrationStatus_RegistrationStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* ModemRegistration_RegistrationStatus_descriptor();
inline const ::std::string& ModemRegistration_RegistrationStatus_Name(ModemRegistration_RegistrationStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    ModemRegistration_RegistrationStatus_descriptor(), value);
}
inline bool ModemRegistration_RegistrationStatus_Parse(
    const ::std::string& name, ModemRegistration_RegistrationStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ModemRegistration_RegistrationStatus>(
    ModemRegistration_RegistrationStatus_descriptor(), name, value);
}
enum ModemRegistration_RadioAccessTechnology {
  ModemRegistration_RadioAccessTechnology_RAT_NOT_SET = 0,
  ModemRegistration_RadioAccessTechnology_RAT_GSM = 1,
  ModemRegistration_RadioAccessTechnology_RAT_GSMC = 2,
  ModemRegistration_RadioAccessTechnology_RAT_UTRAN = 3,
  ModemRegistration_RadioAccessTechnology_RAT_GSMEDGE = 4,
  ModemRegistration_RadioAccessTechnology_RAT_UTRAND = 5,
  ModemRegistration_RadioAccessTechnology_RAT_UTRANU = 6,
  ModemRegistration_RadioAccessTechnology_RAT_UTRANDU = 7,
  ModemRegistration_RadioAccessTechnology_RAT_EUTRAN = 8,
  ModemRegistration_RadioAccessTechnology_RAT_INVALID = 9
};
bool ModemRegistration_RadioAccessTechnology_IsValid(int value);
const ModemRegistration_RadioAccessTechnology ModemRegistration_RadioAccessTechnology_RadioAccessTechnology_MIN = ModemRegistration_RadioAccessTechnology_RAT_NOT_SET;
const ModemRegistration_RadioAccessTechnology ModemRegistration_RadioAccessTechnology_RadioAccessTechnology_MAX = ModemRegistration_RadioAccessTechnology_RAT_INVALID;
const int ModemRegistration_RadioAccessTechnology_RadioAccessTechnology_ARRAYSIZE = ModemRegistration_RadioAccessTechnology_RadioAccessTechnology_MAX + 1;

const ::google::protobuf::EnumDescriptor* ModemRegistration_RadioAccessTechnology_descriptor();
inline const ::std::string& ModemRegistration_RadioAccessTechnology_Name(ModemRegistration_RadioAccessTechnology value) {
  return ::google::protobuf::internal::NameOfEnum(
    ModemRegistration_RadioAccessTechnology_descriptor(), value);
}
inline bool ModemRegistration_RadioAccessTechnology_Parse(
    const ::std::string& name, ModemRegistration_RadioAccessTechnology* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ModemRegistration_RadioAccessTechnology>(
    ModemRegistration_RadioAccessTechnology_descriptor(), name, value);
}
enum ModemRegistration_ExtPSRegStatus {
  ModemRegistration_ExtPSRegStatus_EPSRS_NOT_SET = 0,
  ModemRegistration_ExtPSRegStatus_EPSRS_NONE = 1,
  ModemRegistration_ExtPSRegStatus_EPSRS_GPRS = 2,
  ModemRegistration_ExtPSRegStatus_EPSRS_EDGE = 3,
  ModemRegistration_ExtPSRegStatus_EPSRS_WCDMA = 4,
  ModemRegistration_ExtPSRegStatus_EPSRS_HSDPA = 5,
  ModemRegistration_ExtPSRegStatus_EPSRS_HSUPA = 6,
  ModemRegistration_ExtPSRegStatus_EPSRS_HSDUPA = 7,
  ModemRegistration_ExtPSRegStatus_EPSRS_LTE = 8,
  ModemRegistration_ExtPSRegStatus_EPSRS_GPRSDTM = 9,
  ModemRegistration_ExtPSRegStatus_EPSRS_EDGEDTM = 10
};
bool ModemRegistration_ExtPSRegStatus_IsValid(int value);
const ModemRegistration_ExtPSRegStatus ModemRegistration_ExtPSRegStatus_ExtPSRegStatus_MIN = ModemRegistration_ExtPSRegStatus_EPSRS_NOT_SET;
const ModemRegistration_ExtPSRegStatus ModemRegistration_ExtPSRegStatus_ExtPSRegStatus_MAX = ModemRegistration_ExtPSRegStatus_EPSRS_EDGEDTM;
const int ModemRegistration_ExtPSRegStatus_ExtPSRegStatus_ARRAYSIZE = ModemRegistration_ExtPSRegStatus_ExtPSRegStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* ModemRegistration_ExtPSRegStatus_descriptor();
inline const ::std::string& ModemRegistration_ExtPSRegStatus_Name(ModemRegistration_ExtPSRegStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    ModemRegistration_ExtPSRegStatus_descriptor(), value);
}
inline bool ModemRegistration_ExtPSRegStatus_Parse(
    const ::std::string& name, ModemRegistration_ExtPSRegStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ModemRegistration_ExtPSRegStatus>(
    ModemRegistration_ExtPSRegStatus_descriptor(), name, value);
}
enum ModemStatus_ModemState {
  ModemStatus_ModemState_Failed = -1,
  ModemStatus_ModemState_Unknown = 0,
  ModemStatus_ModemState_Init = 1,
  ModemStatus_ModemState_Locked = 2,
  ModemStatus_ModemState_Disable = 3,
  ModemStatus_ModemState_Disabling = 4,
  ModemStatus_ModemState_Enabling = 5,
  ModemStatus_ModemState_Enabled = 6,
  ModemStatus_ModemState_Searching = 7,
  ModemStatus_ModemState_Registered = 8,
  ModemStatus_ModemState_Disconnecting = 9,
  ModemStatus_ModemState_Connecting = 10,
  ModemStatus_ModemState_Connected = 11
};
bool ModemStatus_ModemState_IsValid(int value);
const ModemStatus_ModemState ModemStatus_ModemState_ModemState_MIN = ModemStatus_ModemState_Failed;
const ModemStatus_ModemState ModemStatus_ModemState_ModemState_MAX = ModemStatus_ModemState_Connected;
const int ModemStatus_ModemState_ModemState_ARRAYSIZE = ModemStatus_ModemState_ModemState_MAX + 1;

const ::google::protobuf::EnumDescriptor* ModemStatus_ModemState_descriptor();
inline const ::std::string& ModemStatus_ModemState_Name(ModemStatus_ModemState value) {
  return ::google::protobuf::internal::NameOfEnum(
    ModemStatus_ModemState_descriptor(), value);
}
inline bool ModemStatus_ModemState_Parse(
    const ::std::string& name, ModemStatus_ModemState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ModemStatus_ModemState>(
    ModemStatus_ModemState_descriptor(), name, value);
}
enum ModemStatus_AccessTechnology {
  ModemStatus_AccessTechnology_AccessUnknown = 0,
  ModemStatus_AccessTechnology_POTS = 1,
  ModemStatus_AccessTechnology_GSM = 2,
  ModemStatus_AccessTechnology_COMPACT = 4,
  ModemStatus_AccessTechnology_GPRS = 8,
  ModemStatus_AccessTechnology_EDGE = 16,
  ModemStatus_AccessTechnology_UMTS = 32,
  ModemStatus_AccessTechnology_HSDPA = 64,
  ModemStatus_AccessTechnology_HSUPA = 128,
  ModemStatus_AccessTechnology_HSPA = 256,
  ModemStatus_AccessTechnology_HSPA_PLUS = 512,
  ModemStatus_AccessTechnology_lXRTT = 1024,
  ModemStatus_AccessTechnology_EVDO0 = 2048,
  ModemStatus_AccessTechnology_EVDOA = 4096,
  ModemStatus_AccessTechnology_EVDOB = 8192,
  ModemStatus_AccessTechnology_LTE = 16384,
  ModemStatus_AccessTechnology_ANY = 65535
};
bool ModemStatus_AccessTechnology_IsValid(int value);
const ModemStatus_AccessTechnology ModemStatus_AccessTechnology_AccessTechnology_MIN = ModemStatus_AccessTechnology_AccessUnknown;
const ModemStatus_AccessTechnology ModemStatus_AccessTechnology_AccessTechnology_MAX = ModemStatus_AccessTechnology_ANY;
const int ModemStatus_AccessTechnology_AccessTechnology_ARRAYSIZE = ModemStatus_AccessTechnology_AccessTechnology_MAX + 1;

const ::google::protobuf::EnumDescriptor* ModemStatus_AccessTechnology_descriptor();
inline const ::std::string& ModemStatus_AccessTechnology_Name(ModemStatus_AccessTechnology value) {
  return ::google::protobuf::internal::NameOfEnum(
    ModemStatus_AccessTechnology_descriptor(), value);
}
inline bool ModemStatus_AccessTechnology_Parse(
    const ::std::string& name, ModemStatus_AccessTechnology* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ModemStatus_AccessTechnology>(
    ModemStatus_AccessTechnology_descriptor(), name, value);
}
enum ModemStatus_ModemResetReason {
  ModemStatus_ModemResetReason_RR_UNKNOWN = 0,
  ModemStatus_ModemResetReason_RR_SIM_CARD_ERROR = 1,
  ModemStatus_ModemResetReason_RR_PORT_UNAVAILABLE = 2,
  ModemStatus_ModemResetReason_RR_PORT_TIMEOUT = 3,
  ModemStatus_ModemResetReason_RR_PORT_WRITE_ERROR = 4,
  ModemStatus_ModemResetReason_RR_INITIALIZATION_FAIL = 5,
  ModemStatus_ModemResetReason_RR_CONTEXT_ERROR = 6,
  ModemStatus_ModemResetReason_RR_NETWORK_ERROR = 7,
  ModemStatus_ModemResetReason_RR_BE_UNAVAILABLE = 8
};
bool ModemStatus_ModemResetReason_IsValid(int value);
const ModemStatus_ModemResetReason ModemStatus_ModemResetReason_ModemResetReason_MIN = ModemStatus_ModemResetReason_RR_UNKNOWN;
const ModemStatus_ModemResetReason ModemStatus_ModemResetReason_ModemResetReason_MAX = ModemStatus_ModemResetReason_RR_BE_UNAVAILABLE;
const int ModemStatus_ModemResetReason_ModemResetReason_ARRAYSIZE = ModemStatus_ModemResetReason_ModemResetReason_MAX + 1;

const ::google::protobuf::EnumDescriptor* ModemStatus_ModemResetReason_descriptor();
inline const ::std::string& ModemStatus_ModemResetReason_Name(ModemStatus_ModemResetReason value) {
  return ::google::protobuf::internal::NameOfEnum(
    ModemStatus_ModemResetReason_descriptor(), value);
}
inline bool ModemStatus_ModemResetReason_Parse(
    const ::std::string& name, ModemStatus_ModemResetReason* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ModemStatus_ModemResetReason>(
    ModemStatus_ModemResetReason_descriptor(), name, value);
}
enum ModemSimType {
  SIMTYPE_UNKNOWN = 0,
  SIMTYPE_INTERNAL = 1,
  SIMTYPE_EXTERNAL = 2
};
bool ModemSimType_IsValid(int value);
const ModemSimType ModemSimType_MIN = SIMTYPE_UNKNOWN;
const ModemSimType ModemSimType_MAX = SIMTYPE_EXTERNAL;
const int ModemSimType_ARRAYSIZE = ModemSimType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ModemSimType_descriptor();
inline const ::std::string& ModemSimType_Name(ModemSimType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ModemSimType_descriptor(), value);
}
inline bool ModemSimType_Parse(
    const ::std::string& name, ModemSimType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ModemSimType>(
    ModemSimType_descriptor(), name, value);
}
// ===================================================================

class ModemSim : public ::google::protobuf::Message {
 public:
  ModemSim();
  virtual ~ModemSim();

  ModemSim(const ModemSim& from);

  inline ModemSim& operator=(const ModemSim& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ModemSim& default_instance();

  void Swap(ModemSim* other);

  // implements Message ----------------------------------------------

  ModemSim* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ModemSim& from);
  void MergeFrom(const ModemSim& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ecu.lapi.pb.ModemSimType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::ecu::lapi::pb::ModemSimType type() const;
  inline void set_type(::ecu::lapi::pb::ModemSimType value);

  // optional string imsi = 2;
  inline bool has_imsi() const;
  inline void clear_imsi();
  static const int kImsiFieldNumber = 2;
  inline const ::std::string& imsi() const;
  inline void set_imsi(const ::std::string& value);
  inline void set_imsi(const char* value);
  inline void set_imsi(const char* value, size_t size);
  inline ::std::string* mutable_imsi();
  inline ::std::string* release_imsi();
  inline void set_allocated_imsi(::std::string* imsi);

  // optional string iccid = 3;
  inline bool has_iccid() const;
  inline void clear_iccid();
  static const int kIccidFieldNumber = 3;
  inline const ::std::string& iccid() const;
  inline void set_iccid(const ::std::string& value);
  inline void set_iccid(const char* value);
  inline void set_iccid(const char* value, size_t size);
  inline ::std::string* mutable_iccid();
  inline ::std::string* release_iccid();
  inline void set_allocated_iccid(::std::string* iccid);

  // @@protoc_insertion_point(class_scope:ecu.lapi.pb.ModemSim)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_imsi();
  inline void clear_has_imsi();
  inline void set_has_iccid();
  inline void clear_has_iccid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* imsi_;
  ::std::string* iccid_;
  int type_;
  friend void  protobuf_AddDesc_modem_2eproto();
  friend void protobuf_AssignDesc_modem_2eproto();
  friend void protobuf_ShutdownFile_modem_2eproto();

  void InitAsDefaultInstance();
  static ModemSim* default_instance_;
};
// -------------------------------------------------------------------

class ModemSimInformation : public ::google::protobuf::Message {
 public:
  ModemSimInformation();
  virtual ~ModemSimInformation();

  ModemSimInformation(const ModemSimInformation& from);

  inline ModemSimInformation& operator=(const ModemSimInformation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ModemSimInformation& default_instance();

  void Swap(ModemSimInformation* other);

  // implements Message ----------------------------------------------

  ModemSimInformation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ModemSimInformation& from);
  void MergeFrom(const ModemSimInformation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ecu.lapi.pb.ModemSim internal = 1;
  inline bool has_internal() const;
  inline void clear_internal();
  static const int kInternalFieldNumber = 1;
  inline const ::ecu::lapi::pb::ModemSim& internal() const;
  inline ::ecu::lapi::pb::ModemSim* mutable_internal();
  inline ::ecu::lapi::pb::ModemSim* release_internal();
  inline void set_allocated_internal(::ecu::lapi::pb::ModemSim* internal);

  // optional .ecu.lapi.pb.ModemSim external = 2;
  inline bool has_external() const;
  inline void clear_external();
  static const int kExternalFieldNumber = 2;
  inline const ::ecu::lapi::pb::ModemSim& external() const;
  inline ::ecu::lapi::pb::ModemSim* mutable_external();
  inline ::ecu::lapi::pb::ModemSim* release_external();
  inline void set_allocated_external(::ecu::lapi::pb::ModemSim* external);

  // optional .ecu.lapi.pb.ModemSimType active = 3;
  inline bool has_active() const;
  inline void clear_active();
  static const int kActiveFieldNumber = 3;
  inline ::ecu::lapi::pb::ModemSimType active() const;
  inline void set_active(::ecu::lapi::pb::ModemSimType value);

  // @@protoc_insertion_point(class_scope:ecu.lapi.pb.ModemSimInformation)
 private:
  inline void set_has_internal();
  inline void clear_has_internal();
  inline void set_has_external();
  inline void clear_has_external();
  inline void set_has_active();
  inline void clear_has_active();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::ecu::lapi::pb::ModemSim* internal_;
  ::ecu::lapi::pb::ModemSim* external_;
  int active_;
  friend void  protobuf_AddDesc_modem_2eproto();
  friend void protobuf_AssignDesc_modem_2eproto();
  friend void protobuf_ShutdownFile_modem_2eproto();

  void InitAsDefaultInstance();
  static ModemSimInformation* default_instance_;
};
// -------------------------------------------------------------------

class ModemHardware : public ::google::protobuf::Message {
 public:
  ModemHardware();
  virtual ~ModemHardware();

  ModemHardware(const ModemHardware& from);

  inline ModemHardware& operator=(const ModemHardware& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ModemHardware& default_instance();

  void Swap(ModemHardware* other);

  // implements Message ----------------------------------------------

  ModemHardware* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ModemHardware& from);
  void MergeFrom(const ModemHardware& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string imei = 1;
  inline bool has_imei() const;
  inline void clear_imei();
  static const int kImeiFieldNumber = 1;
  inline const ::std::string& imei() const;
  inline void set_imei(const ::std::string& value);
  inline void set_imei(const char* value);
  inline void set_imei(const char* value, size_t size);
  inline ::std::string* mutable_imei();
  inline ::std::string* release_imei();
  inline void set_allocated_imei(::std::string* imei);

  // optional string manufacturer = 2;
  inline bool has_manufacturer() const;
  inline void clear_manufacturer();
  static const int kManufacturerFieldNumber = 2;
  inline const ::std::string& manufacturer() const;
  inline void set_manufacturer(const ::std::string& value);
  inline void set_manufacturer(const char* value);
  inline void set_manufacturer(const char* value, size_t size);
  inline ::std::string* mutable_manufacturer();
  inline ::std::string* release_manufacturer();
  inline void set_allocated_manufacturer(::std::string* manufacturer);

  // optional string model = 3;
  inline bool has_model() const;
  inline void clear_model();
  static const int kModelFieldNumber = 3;
  inline const ::std::string& model() const;
  inline void set_model(const ::std::string& value);
  inline void set_model(const char* value);
  inline void set_model(const char* value, size_t size);
  inline ::std::string* mutable_model();
  inline ::std::string* release_model();
  inline void set_allocated_model(::std::string* model);

  // @@protoc_insertion_point(class_scope:ecu.lapi.pb.ModemHardware)
 private:
  inline void set_has_imei();
  inline void clear_has_imei();
  inline void set_has_manufacturer();
  inline void clear_has_manufacturer();
  inline void set_has_model();
  inline void clear_has_model();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* imei_;
  ::std::string* manufacturer_;
  ::std::string* model_;
  friend void  protobuf_AddDesc_modem_2eproto();
  friend void protobuf_AssignDesc_modem_2eproto();
  friend void protobuf_ShutdownFile_modem_2eproto();

  void InitAsDefaultInstance();
  static ModemHardware* default_instance_;
};
// -------------------------------------------------------------------

class ModemRegistration : public ::google::protobuf::Message {
 public:
  ModemRegistration();
  virtual ~ModemRegistration();

  ModemRegistration(const ModemRegistration& from);

  inline ModemRegistration& operator=(const ModemRegistration& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ModemRegistration& default_instance();

  void Swap(ModemRegistration* other);

  // implements Message ----------------------------------------------

  ModemRegistration* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ModemRegistration& from);
  void MergeFrom(const ModemRegistration& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ModemRegistration_RegistrationStatus RegistrationStatus;
  static const RegistrationStatus RS_NOT_SET = ModemRegistration_RegistrationStatus_RS_NOT_SET;
  static const RegistrationStatus RS_NOTREG = ModemRegistration_RegistrationStatus_RS_NOTREG;
  static const RegistrationStatus RS_HOME = ModemRegistration_RegistrationStatus_RS_HOME;
  static const RegistrationStatus RS_SEARCH = ModemRegistration_RegistrationStatus_RS_SEARCH;
  static const RegistrationStatus RS_DENIED = ModemRegistration_RegistrationStatus_RS_DENIED;
  static const RegistrationStatus RS_UNKNOWN = ModemRegistration_RegistrationStatus_RS_UNKNOWN;
  static const RegistrationStatus RS_ROAMING = ModemRegistration_RegistrationStatus_RS_ROAMING;
  static const RegistrationStatus RS_SMSHOME = ModemRegistration_RegistrationStatus_RS_SMSHOME;
  static const RegistrationStatus RS_SMSROAM = ModemRegistration_RegistrationStatus_RS_SMSROAM;
  static const RegistrationStatus RS_EMERGENCY = ModemRegistration_RegistrationStatus_RS_EMERGENCY;
  static const RegistrationStatus RS_NCSFBHOME = ModemRegistration_RegistrationStatus_RS_NCSFBHOME;
  static const RegistrationStatus RS_NCSFBROAM = ModemRegistration_RegistrationStatus_RS_NCSFBROAM;
  static inline bool RegistrationStatus_IsValid(int value) {
    return ModemRegistration_RegistrationStatus_IsValid(value);
  }
  static const RegistrationStatus RegistrationStatus_MIN =
    ModemRegistration_RegistrationStatus_RegistrationStatus_MIN;
  static const RegistrationStatus RegistrationStatus_MAX =
    ModemRegistration_RegistrationStatus_RegistrationStatus_MAX;
  static const int RegistrationStatus_ARRAYSIZE =
    ModemRegistration_RegistrationStatus_RegistrationStatus_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RegistrationStatus_descriptor() {
    return ModemRegistration_RegistrationStatus_descriptor();
  }
  static inline const ::std::string& RegistrationStatus_Name(RegistrationStatus value) {
    return ModemRegistration_RegistrationStatus_Name(value);
  }
  static inline bool RegistrationStatus_Parse(const ::std::string& name,
      RegistrationStatus* value) {
    return ModemRegistration_RegistrationStatus_Parse(name, value);
  }

  typedef ModemRegistration_RadioAccessTechnology RadioAccessTechnology;
  static const RadioAccessTechnology RAT_NOT_SET = ModemRegistration_RadioAccessTechnology_RAT_NOT_SET;
  static const RadioAccessTechnology RAT_GSM = ModemRegistration_RadioAccessTechnology_RAT_GSM;
  static const RadioAccessTechnology RAT_GSMC = ModemRegistration_RadioAccessTechnology_RAT_GSMC;
  static const RadioAccessTechnology RAT_UTRAN = ModemRegistration_RadioAccessTechnology_RAT_UTRAN;
  static const RadioAccessTechnology RAT_GSMEDGE = ModemRegistration_RadioAccessTechnology_RAT_GSMEDGE;
  static const RadioAccessTechnology RAT_UTRAND = ModemRegistration_RadioAccessTechnology_RAT_UTRAND;
  static const RadioAccessTechnology RAT_UTRANU = ModemRegistration_RadioAccessTechnology_RAT_UTRANU;
  static const RadioAccessTechnology RAT_UTRANDU = ModemRegistration_RadioAccessTechnology_RAT_UTRANDU;
  static const RadioAccessTechnology RAT_EUTRAN = ModemRegistration_RadioAccessTechnology_RAT_EUTRAN;
  static const RadioAccessTechnology RAT_INVALID = ModemRegistration_RadioAccessTechnology_RAT_INVALID;
  static inline bool RadioAccessTechnology_IsValid(int value) {
    return ModemRegistration_RadioAccessTechnology_IsValid(value);
  }
  static const RadioAccessTechnology RadioAccessTechnology_MIN =
    ModemRegistration_RadioAccessTechnology_RadioAccessTechnology_MIN;
  static const RadioAccessTechnology RadioAccessTechnology_MAX =
    ModemRegistration_RadioAccessTechnology_RadioAccessTechnology_MAX;
  static const int RadioAccessTechnology_ARRAYSIZE =
    ModemRegistration_RadioAccessTechnology_RadioAccessTechnology_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RadioAccessTechnology_descriptor() {
    return ModemRegistration_RadioAccessTechnology_descriptor();
  }
  static inline const ::std::string& RadioAccessTechnology_Name(RadioAccessTechnology value) {
    return ModemRegistration_RadioAccessTechnology_Name(value);
  }
  static inline bool RadioAccessTechnology_Parse(const ::std::string& name,
      RadioAccessTechnology* value) {
    return ModemRegistration_RadioAccessTechnology_Parse(name, value);
  }

  typedef ModemRegistration_ExtPSRegStatus ExtPSRegStatus;
  static const ExtPSRegStatus EPSRS_NOT_SET = ModemRegistration_ExtPSRegStatus_EPSRS_NOT_SET;
  static const ExtPSRegStatus EPSRS_NONE = ModemRegistration_ExtPSRegStatus_EPSRS_NONE;
  static const ExtPSRegStatus EPSRS_GPRS = ModemRegistration_ExtPSRegStatus_EPSRS_GPRS;
  static const ExtPSRegStatus EPSRS_EDGE = ModemRegistration_ExtPSRegStatus_EPSRS_EDGE;
  static const ExtPSRegStatus EPSRS_WCDMA = ModemRegistration_ExtPSRegStatus_EPSRS_WCDMA;
  static const ExtPSRegStatus EPSRS_HSDPA = ModemRegistration_ExtPSRegStatus_EPSRS_HSDPA;
  static const ExtPSRegStatus EPSRS_HSUPA = ModemRegistration_ExtPSRegStatus_EPSRS_HSUPA;
  static const ExtPSRegStatus EPSRS_HSDUPA = ModemRegistration_ExtPSRegStatus_EPSRS_HSDUPA;
  static const ExtPSRegStatus EPSRS_LTE = ModemRegistration_ExtPSRegStatus_EPSRS_LTE;
  static const ExtPSRegStatus EPSRS_GPRSDTM = ModemRegistration_ExtPSRegStatus_EPSRS_GPRSDTM;
  static const ExtPSRegStatus EPSRS_EDGEDTM = ModemRegistration_ExtPSRegStatus_EPSRS_EDGEDTM;
  static inline bool ExtPSRegStatus_IsValid(int value) {
    return ModemRegistration_ExtPSRegStatus_IsValid(value);
  }
  static const ExtPSRegStatus ExtPSRegStatus_MIN =
    ModemRegistration_ExtPSRegStatus_ExtPSRegStatus_MIN;
  static const ExtPSRegStatus ExtPSRegStatus_MAX =
    ModemRegistration_ExtPSRegStatus_ExtPSRegStatus_MAX;
  static const int ExtPSRegStatus_ARRAYSIZE =
    ModemRegistration_ExtPSRegStatus_ExtPSRegStatus_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ExtPSRegStatus_descriptor() {
    return ModemRegistration_ExtPSRegStatus_descriptor();
  }
  static inline const ::std::string& ExtPSRegStatus_Name(ExtPSRegStatus value) {
    return ModemRegistration_ExtPSRegStatus_Name(value);
  }
  static inline bool ExtPSRegStatus_Parse(const ::std::string& name,
      ExtPSRegStatus* value) {
    return ModemRegistration_ExtPSRegStatus_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .ecu.lapi.pb.ModemRegistration.RadioAccessTechnology rat = 1;
  inline bool has_rat() const;
  inline void clear_rat();
  static const int kRatFieldNumber = 1;
  inline ::ecu::lapi::pb::ModemRegistration_RadioAccessTechnology rat() const;
  inline void set_rat(::ecu::lapi::pb::ModemRegistration_RadioAccessTechnology value);

  // optional .ecu.lapi.pb.ModemRegistration.RegistrationStatus reg_status = 2;
  inline bool has_reg_status() const;
  inline void clear_reg_status();
  static const int kRegStatusFieldNumber = 2;
  inline ::ecu::lapi::pb::ModemRegistration_RegistrationStatus reg_status() const;
  inline void set_reg_status(::ecu::lapi::pb::ModemRegistration_RegistrationStatus value);

  // optional .ecu.lapi.pb.ModemRegistration.ExtPSRegStatus ps_reg_status = 3;
  inline bool has_ps_reg_status() const;
  inline void clear_ps_reg_status();
  static const int kPsRegStatusFieldNumber = 3;
  inline ::ecu::lapi::pb::ModemRegistration_ExtPSRegStatus ps_reg_status() const;
  inline void set_ps_reg_status(::ecu::lapi::pb::ModemRegistration_ExtPSRegStatus value);

  // @@protoc_insertion_point(class_scope:ecu.lapi.pb.ModemRegistration)
 private:
  inline void set_has_rat();
  inline void clear_has_rat();
  inline void set_has_reg_status();
  inline void clear_has_reg_status();
  inline void set_has_ps_reg_status();
  inline void clear_has_ps_reg_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int rat_;
  int reg_status_;
  int ps_reg_status_;
  friend void  protobuf_AddDesc_modem_2eproto();
  friend void protobuf_AssignDesc_modem_2eproto();
  friend void protobuf_ShutdownFile_modem_2eproto();

  void InitAsDefaultInstance();
  static ModemRegistration* default_instance_;
};
// -------------------------------------------------------------------

class ModemLocation : public ::google::protobuf::Message {
 public:
  ModemLocation();
  virtual ~ModemLocation();

  ModemLocation(const ModemLocation& from);

  inline ModemLocation& operator=(const ModemLocation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ModemLocation& default_instance();

  void Swap(ModemLocation* other);

  // implements Message ----------------------------------------------

  ModemLocation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ModemLocation& from);
  void MergeFrom(const ModemLocation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 country_code = 1;
  inline bool has_country_code() const;
  inline void clear_country_code();
  static const int kCountryCodeFieldNumber = 1;
  inline ::google::protobuf::uint32 country_code() const;
  inline void set_country_code(::google::protobuf::uint32 value);

  // optional uint32 network_code = 2;
  inline bool has_network_code() const;
  inline void clear_network_code();
  static const int kNetworkCodeFieldNumber = 2;
  inline ::google::protobuf::uint32 network_code() const;
  inline void set_network_code(::google::protobuf::uint32 value);

  // optional uint32 area_code = 3;
  inline bool has_area_code() const;
  inline void clear_area_code();
  static const int kAreaCodeFieldNumber = 3;
  inline ::google::protobuf::uint32 area_code() const;
  inline void set_area_code(::google::protobuf::uint32 value);

  // optional uint32 cell_id = 4;
  inline bool has_cell_id() const;
  inline void clear_cell_id();
  static const int kCellIdFieldNumber = 4;
  inline ::google::protobuf::uint32 cell_id() const;
  inline void set_cell_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ecu.lapi.pb.ModemLocation)
 private:
  inline void set_has_country_code();
  inline void clear_has_country_code();
  inline void set_has_network_code();
  inline void clear_has_network_code();
  inline void set_has_area_code();
  inline void clear_has_area_code();
  inline void set_has_cell_id();
  inline void clear_has_cell_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 country_code_;
  ::google::protobuf::uint32 network_code_;
  ::google::protobuf::uint32 area_code_;
  ::google::protobuf::uint32 cell_id_;
  friend void  protobuf_AddDesc_modem_2eproto();
  friend void protobuf_AssignDesc_modem_2eproto();
  friend void protobuf_ShutdownFile_modem_2eproto();

  void InitAsDefaultInstance();
  static ModemLocation* default_instance_;
};
// -------------------------------------------------------------------

class ModemStatus : public ::google::protobuf::Message {
 public:
  ModemStatus();
  virtual ~ModemStatus();

  ModemStatus(const ModemStatus& from);

  inline ModemStatus& operator=(const ModemStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ModemStatus& default_instance();

  void Swap(ModemStatus* other);

  // implements Message ----------------------------------------------

  ModemStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ModemStatus& from);
  void MergeFrom(const ModemStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ModemStatus_ModemState ModemState;
  static const ModemState Failed = ModemStatus_ModemState_Failed;
  static const ModemState Unknown = ModemStatus_ModemState_Unknown;
  static const ModemState Init = ModemStatus_ModemState_Init;
  static const ModemState Locked = ModemStatus_ModemState_Locked;
  static const ModemState Disable = ModemStatus_ModemState_Disable;
  static const ModemState Disabling = ModemStatus_ModemState_Disabling;
  static const ModemState Enabling = ModemStatus_ModemState_Enabling;
  static const ModemState Enabled = ModemStatus_ModemState_Enabled;
  static const ModemState Searching = ModemStatus_ModemState_Searching;
  static const ModemState Registered = ModemStatus_ModemState_Registered;
  static const ModemState Disconnecting = ModemStatus_ModemState_Disconnecting;
  static const ModemState Connecting = ModemStatus_ModemState_Connecting;
  static const ModemState Connected = ModemStatus_ModemState_Connected;
  static inline bool ModemState_IsValid(int value) {
    return ModemStatus_ModemState_IsValid(value);
  }
  static const ModemState ModemState_MIN =
    ModemStatus_ModemState_ModemState_MIN;
  static const ModemState ModemState_MAX =
    ModemStatus_ModemState_ModemState_MAX;
  static const int ModemState_ARRAYSIZE =
    ModemStatus_ModemState_ModemState_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ModemState_descriptor() {
    return ModemStatus_ModemState_descriptor();
  }
  static inline const ::std::string& ModemState_Name(ModemState value) {
    return ModemStatus_ModemState_Name(value);
  }
  static inline bool ModemState_Parse(const ::std::string& name,
      ModemState* value) {
    return ModemStatus_ModemState_Parse(name, value);
  }

  typedef ModemStatus_AccessTechnology AccessTechnology;
  static const AccessTechnology AccessUnknown = ModemStatus_AccessTechnology_AccessUnknown;
  static const AccessTechnology POTS = ModemStatus_AccessTechnology_POTS;
  static const AccessTechnology GSM = ModemStatus_AccessTechnology_GSM;
  static const AccessTechnology COMPACT = ModemStatus_AccessTechnology_COMPACT;
  static const AccessTechnology GPRS = ModemStatus_AccessTechnology_GPRS;
  static const AccessTechnology EDGE = ModemStatus_AccessTechnology_EDGE;
  static const AccessTechnology UMTS = ModemStatus_AccessTechnology_UMTS;
  static const AccessTechnology HSDPA = ModemStatus_AccessTechnology_HSDPA;
  static const AccessTechnology HSUPA = ModemStatus_AccessTechnology_HSUPA;
  static const AccessTechnology HSPA = ModemStatus_AccessTechnology_HSPA;
  static const AccessTechnology HSPA_PLUS = ModemStatus_AccessTechnology_HSPA_PLUS;
  static const AccessTechnology lXRTT = ModemStatus_AccessTechnology_lXRTT;
  static const AccessTechnology EVDO0 = ModemStatus_AccessTechnology_EVDO0;
  static const AccessTechnology EVDOA = ModemStatus_AccessTechnology_EVDOA;
  static const AccessTechnology EVDOB = ModemStatus_AccessTechnology_EVDOB;
  static const AccessTechnology LTE = ModemStatus_AccessTechnology_LTE;
  static const AccessTechnology ANY = ModemStatus_AccessTechnology_ANY;
  static inline bool AccessTechnology_IsValid(int value) {
    return ModemStatus_AccessTechnology_IsValid(value);
  }
  static const AccessTechnology AccessTechnology_MIN =
    ModemStatus_AccessTechnology_AccessTechnology_MIN;
  static const AccessTechnology AccessTechnology_MAX =
    ModemStatus_AccessTechnology_AccessTechnology_MAX;
  static const int AccessTechnology_ARRAYSIZE =
    ModemStatus_AccessTechnology_AccessTechnology_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  AccessTechnology_descriptor() {
    return ModemStatus_AccessTechnology_descriptor();
  }
  static inline const ::std::string& AccessTechnology_Name(AccessTechnology value) {
    return ModemStatus_AccessTechnology_Name(value);
  }
  static inline bool AccessTechnology_Parse(const ::std::string& name,
      AccessTechnology* value) {
    return ModemStatus_AccessTechnology_Parse(name, value);
  }

  typedef ModemStatus_ModemResetReason ModemResetReason;
  static const ModemResetReason RR_UNKNOWN = ModemStatus_ModemResetReason_RR_UNKNOWN;
  static const ModemResetReason RR_SIM_CARD_ERROR = ModemStatus_ModemResetReason_RR_SIM_CARD_ERROR;
  static const ModemResetReason RR_PORT_UNAVAILABLE = ModemStatus_ModemResetReason_RR_PORT_UNAVAILABLE;
  static const ModemResetReason RR_PORT_TIMEOUT = ModemStatus_ModemResetReason_RR_PORT_TIMEOUT;
  static const ModemResetReason RR_PORT_WRITE_ERROR = ModemStatus_ModemResetReason_RR_PORT_WRITE_ERROR;
  static const ModemResetReason RR_INITIALIZATION_FAIL = ModemStatus_ModemResetReason_RR_INITIALIZATION_FAIL;
  static const ModemResetReason RR_CONTEXT_ERROR = ModemStatus_ModemResetReason_RR_CONTEXT_ERROR;
  static const ModemResetReason RR_NETWORK_ERROR = ModemStatus_ModemResetReason_RR_NETWORK_ERROR;
  static const ModemResetReason RR_BE_UNAVAILABLE = ModemStatus_ModemResetReason_RR_BE_UNAVAILABLE;
  static inline bool ModemResetReason_IsValid(int value) {
    return ModemStatus_ModemResetReason_IsValid(value);
  }
  static const ModemResetReason ModemResetReason_MIN =
    ModemStatus_ModemResetReason_ModemResetReason_MIN;
  static const ModemResetReason ModemResetReason_MAX =
    ModemStatus_ModemResetReason_ModemResetReason_MAX;
  static const int ModemResetReason_ARRAYSIZE =
    ModemStatus_ModemResetReason_ModemResetReason_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ModemResetReason_descriptor() {
    return ModemStatus_ModemResetReason_descriptor();
  }
  static inline const ::std::string& ModemResetReason_Name(ModemResetReason value) {
    return ModemStatus_ModemResetReason_Name(value);
  }
  static inline bool ModemResetReason_Parse(const ::std::string& name,
      ModemResetReason* value) {
    return ModemStatus_ModemResetReason_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string modem_manufacturer = 1;
  inline bool has_modem_manufacturer() const;
  inline void clear_modem_manufacturer();
  static const int kModemManufacturerFieldNumber = 1;
  inline const ::std::string& modem_manufacturer() const;
  inline void set_modem_manufacturer(const ::std::string& value);
  inline void set_modem_manufacturer(const char* value);
  inline void set_modem_manufacturer(const char* value, size_t size);
  inline ::std::string* mutable_modem_manufacturer();
  inline ::std::string* release_modem_manufacturer();
  inline void set_allocated_modem_manufacturer(::std::string* modem_manufacturer);

  // optional string modem_model = 2;
  inline bool has_modem_model() const;
  inline void clear_modem_model();
  static const int kModemModelFieldNumber = 2;
  inline const ::std::string& modem_model() const;
  inline void set_modem_model(const ::std::string& value);
  inline void set_modem_model(const char* value);
  inline void set_modem_model(const char* value, size_t size);
  inline ::std::string* mutable_modem_model();
  inline ::std::string* release_modem_model();
  inline void set_allocated_modem_model(::std::string* modem_model);

  // optional .ecu.lapi.pb.ModemStatus.ModemState modem_state = 3;
  inline bool has_modem_state() const;
  inline void clear_modem_state();
  static const int kModemStateFieldNumber = 3;
  inline ::ecu::lapi::pb::ModemStatus_ModemState modem_state() const;
  inline void set_modem_state(::ecu::lapi::pb::ModemStatus_ModemState value);

  // optional double signal_strength = 4;
  inline bool has_signal_strength() const;
  inline void clear_signal_strength();
  static const int kSignalStrengthFieldNumber = 4;
  inline double signal_strength() const;
  inline void set_signal_strength(double value);

  // optional double signal_quality = 5;
  inline bool has_signal_quality() const;
  inline void clear_signal_quality();
  static const int kSignalQualityFieldNumber = 5;
  inline double signal_quality() const;
  inline void set_signal_quality(double value);

  // optional bool roaming = 6;
  inline bool has_roaming() const;
  inline void clear_roaming();
  static const int kRoamingFieldNumber = 6;
  inline bool roaming() const;
  inline void set_roaming(bool value);

  // optional fixed32 simple_access_bitmask = 7;
  inline bool has_simple_access_bitmask() const;
  inline void clear_simple_access_bitmask();
  static const int kSimpleAccessBitmaskFieldNumber = 7;
  inline ::google::protobuf::uint32 simple_access_bitmask() const;
  inline void set_simple_access_bitmask(::google::protobuf::uint32 value);

  // optional int32 simple_signal_quality = 8;
  inline bool has_simple_signal_quality() const;
  inline void clear_simple_signal_quality();
  static const int kSimpleSignalQualityFieldNumber = 8;
  inline ::google::protobuf::int32 simple_signal_quality() const;
  inline void set_simple_signal_quality(::google::protobuf::int32 value);

  // optional string sim_identifier = 9;
  inline bool has_sim_identifier() const;
  inline void clear_sim_identifier();
  static const int kSimIdentifierFieldNumber = 9;
  inline const ::std::string& sim_identifier() const;
  inline void set_sim_identifier(const ::std::string& value);
  inline void set_sim_identifier(const char* value);
  inline void set_sim_identifier(const char* value, size_t size);
  inline ::std::string* mutable_sim_identifier();
  inline ::std::string* release_sim_identifier();
  inline void set_allocated_sim_identifier(::std::string* sim_identifier);

  // optional string sim_imsi = 10;
  inline bool has_sim_imsi() const;
  inline void clear_sim_imsi();
  static const int kSimImsiFieldNumber = 10;
  inline const ::std::string& sim_imsi() const;
  inline void set_sim_imsi(const ::std::string& value);
  inline void set_sim_imsi(const char* value);
  inline void set_sim_imsi(const char* value, size_t size);
  inline ::std::string* mutable_sim_imsi();
  inline ::std::string* release_sim_imsi();
  inline void set_allocated_sim_imsi(::std::string* sim_imsi);

  // optional string sim_operator_name = 11;
  inline bool has_sim_operator_name() const;
  inline void clear_sim_operator_name();
  static const int kSimOperatorNameFieldNumber = 11;
  inline const ::std::string& sim_operator_name() const;
  inline void set_sim_operator_name(const ::std::string& value);
  inline void set_sim_operator_name(const char* value);
  inline void set_sim_operator_name(const char* value, size_t size);
  inline ::std::string* mutable_sim_operator_name();
  inline ::std::string* release_sim_operator_name();
  inline void set_allocated_sim_operator_name(::std::string* sim_operator_name);

  // optional bool sim_active = 12;
  inline bool has_sim_active() const;
  inline void clear_sim_active();
  static const int kSimActiveFieldNumber = 12;
  inline bool sim_active() const;
  inline void set_sim_active(bool value);

  // optional string operator_identifier = 13;
  inline bool has_operator_identifier() const;
  inline void clear_operator_identifier();
  static const int kOperatorIdentifierFieldNumber = 13;
  inline const ::std::string& operator_identifier() const;
  inline void set_operator_identifier(const ::std::string& value);
  inline void set_operator_identifier(const char* value);
  inline void set_operator_identifier(const char* value, size_t size);
  inline ::std::string* mutable_operator_identifier();
  inline ::std::string* release_operator_identifier();
  inline void set_allocated_operator_identifier(::std::string* operator_identifier);

  // optional string operator_name = 14;
  inline bool has_operator_name() const;
  inline void clear_operator_name();
  static const int kOperatorNameFieldNumber = 14;
  inline const ::std::string& operator_name() const;
  inline void set_operator_name(const ::std::string& value);
  inline void set_operator_name(const char* value);
  inline void set_operator_name(const char* value, size_t size);
  inline ::std::string* mutable_operator_name();
  inline ::std::string* release_operator_name();
  inline void set_allocated_operator_name(::std::string* operator_name);

  // optional string imei = 15;
  inline bool has_imei() const;
  inline void clear_imei();
  static const int kImeiFieldNumber = 15;
  inline const ::std::string& imei() const;
  inline void set_imei(const ::std::string& value);
  inline void set_imei(const char* value);
  inline void set_imei(const char* value, size_t size);
  inline ::std::string* mutable_imei();
  inline ::std::string* release_imei();
  inline void set_allocated_imei(::std::string* imei);

  // optional .ecu.lapi.pb.ModemLocation location = 16;
  inline bool has_location() const;
  inline void clear_location();
  static const int kLocationFieldNumber = 16;
  inline const ::ecu::lapi::pb::ModemLocation& location() const;
  inline ::ecu::lapi::pb::ModemLocation* mutable_location();
  inline ::ecu::lapi::pb::ModemLocation* release_location();
  inline void set_allocated_location(::ecu::lapi::pb::ModemLocation* location);

  // optional uint64 network_utc_time = 17;
  inline bool has_network_utc_time() const;
  inline void clear_network_utc_time();
  static const int kNetworkUtcTimeFieldNumber = 17;
  inline ::google::protobuf::uint64 network_utc_time() const;
  inline void set_network_utc_time(::google::protobuf::uint64 value);

  // optional uint64 timestamp_ns = 18;
  inline bool has_timestamp_ns() const;
  inline void clear_timestamp_ns();
  static const int kTimestampNsFieldNumber = 18;
  inline ::google::protobuf::uint64 timestamp_ns() const;
  inline void set_timestamp_ns(::google::protobuf::uint64 value);

  // optional .ecu.lapi.pb.ModemStatus.ModemResetReason reset_reason = 19;
  inline bool has_reset_reason() const;
  inline void clear_reset_reason();
  static const int kResetReasonFieldNumber = 19;
  inline ::ecu::lapi::pb::ModemStatus_ModemResetReason reset_reason() const;
  inline void set_reset_reason(::ecu::lapi::pb::ModemStatus_ModemResetReason value);

  // @@protoc_insertion_point(class_scope:ecu.lapi.pb.ModemStatus)
 private:
  inline void set_has_modem_manufacturer();
  inline void clear_has_modem_manufacturer();
  inline void set_has_modem_model();
  inline void clear_has_modem_model();
  inline void set_has_modem_state();
  inline void clear_has_modem_state();
  inline void set_has_signal_strength();
  inline void clear_has_signal_strength();
  inline void set_has_signal_quality();
  inline void clear_has_signal_quality();
  inline void set_has_roaming();
  inline void clear_has_roaming();
  inline void set_has_simple_access_bitmask();
  inline void clear_has_simple_access_bitmask();
  inline void set_has_simple_signal_quality();
  inline void clear_has_simple_signal_quality();
  inline void set_has_sim_identifier();
  inline void clear_has_sim_identifier();
  inline void set_has_sim_imsi();
  inline void clear_has_sim_imsi();
  inline void set_has_sim_operator_name();
  inline void clear_has_sim_operator_name();
  inline void set_has_sim_active();
  inline void clear_has_sim_active();
  inline void set_has_operator_identifier();
  inline void clear_has_operator_identifier();
  inline void set_has_operator_name();
  inline void clear_has_operator_name();
  inline void set_has_imei();
  inline void clear_has_imei();
  inline void set_has_location();
  inline void clear_has_location();
  inline void set_has_network_utc_time();
  inline void clear_has_network_utc_time();
  inline void set_has_timestamp_ns();
  inline void clear_has_timestamp_ns();
  inline void set_has_reset_reason();
  inline void clear_has_reset_reason();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* modem_manufacturer_;
  ::std::string* modem_model_;
  double signal_strength_;
  double signal_quality_;
  int modem_state_;
  ::google::protobuf::uint32 simple_access_bitmask_;
  ::google::protobuf::int32 simple_signal_quality_;
  bool roaming_;
  bool sim_active_;
  ::std::string* sim_identifier_;
  ::std::string* sim_imsi_;
  ::std::string* sim_operator_name_;
  ::std::string* operator_identifier_;
  ::std::string* operator_name_;
  ::std::string* imei_;
  ::ecu::lapi::pb::ModemLocation* location_;
  ::google::protobuf::uint64 network_utc_time_;
  ::google::protobuf::uint64 timestamp_ns_;
  int reset_reason_;
  friend void  protobuf_AddDesc_modem_2eproto();
  friend void protobuf_AssignDesc_modem_2eproto();
  friend void protobuf_ShutdownFile_modem_2eproto();

  void InitAsDefaultInstance();
  static ModemStatus* default_instance_;
};
// -------------------------------------------------------------------

class ModemSms : public ::google::protobuf::Message {
 public:
  ModemSms();
  virtual ~ModemSms();

  ModemSms(const ModemSms& from);

  inline ModemSms& operator=(const ModemSms& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ModemSms& default_instance();

  void Swap(ModemSms* other);

  // implements Message ----------------------------------------------

  ModemSms* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ModemSms& from);
  void MergeFrom(const ModemSms& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string number = 1;
  inline bool has_number() const;
  inline void clear_number();
  static const int kNumberFieldNumber = 1;
  inline const ::std::string& number() const;
  inline void set_number(const ::std::string& value);
  inline void set_number(const char* value);
  inline void set_number(const char* value, size_t size);
  inline ::std::string* mutable_number();
  inline ::std::string* release_number();
  inline void set_allocated_number(::std::string* number);

  // optional string timestamp = 2;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  inline const ::std::string& timestamp() const;
  inline void set_timestamp(const ::std::string& value);
  inline void set_timestamp(const char* value);
  inline void set_timestamp(const char* value, size_t size);
  inline ::std::string* mutable_timestamp();
  inline ::std::string* release_timestamp();
  inline void set_allocated_timestamp(::std::string* timestamp);

  // optional string content = 3;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 3;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const char* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  inline void set_allocated_content(::std::string* content);

  // @@protoc_insertion_point(class_scope:ecu.lapi.pb.ModemSms)
 private:
  inline void set_has_number();
  inline void clear_has_number();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_content();
  inline void clear_has_content();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* number_;
  ::std::string* timestamp_;
  ::std::string* content_;
  friend void  protobuf_AddDesc_modem_2eproto();
  friend void protobuf_AssignDesc_modem_2eproto();
  friend void protobuf_ShutdownFile_modem_2eproto();

  void InitAsDefaultInstance();
  static ModemSms* default_instance_;
};
// ===================================================================


// ===================================================================

// ModemSim

// optional .ecu.lapi.pb.ModemSimType type = 1;
inline bool ModemSim::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ModemSim::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ModemSim::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ModemSim::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::ecu::lapi::pb::ModemSimType ModemSim::type() const {
  // @@protoc_insertion_point(field_get:ecu.lapi.pb.ModemSim.type)
  return static_cast< ::ecu::lapi::pb::ModemSimType >(type_);
}
inline void ModemSim::set_type(::ecu::lapi::pb::ModemSimType value) {
  assert(::ecu::lapi::pb::ModemSimType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:ecu.lapi.pb.ModemSim.type)
}

// optional string imsi = 2;
inline bool ModemSim::has_imsi() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ModemSim::set_has_imsi() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ModemSim::clear_has_imsi() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ModemSim::clear_imsi() {
  if (imsi_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    imsi_->clear();
  }
  clear_has_imsi();
}
inline const ::std::string& ModemSim::imsi() const {
  // @@protoc_insertion_point(field_get:ecu.lapi.pb.ModemSim.imsi)
  return *imsi_;
}
inline void ModemSim::set_imsi(const ::std::string& value) {
  set_has_imsi();
  if (imsi_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    imsi_ = new ::std::string;
  }
  imsi_->assign(value);
  // @@protoc_insertion_point(field_set:ecu.lapi.pb.ModemSim.imsi)
}
inline void ModemSim::set_imsi(const char* value) {
  set_has_imsi();
  if (imsi_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    imsi_ = new ::std::string;
  }
  imsi_->assign(value);
  // @@protoc_insertion_point(field_set_char:ecu.lapi.pb.ModemSim.imsi)
}
inline void ModemSim::set_imsi(const char* value, size_t size) {
  set_has_imsi();
  if (imsi_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    imsi_ = new ::std::string;
  }
  imsi_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ecu.lapi.pb.ModemSim.imsi)
}
inline ::std::string* ModemSim::mutable_imsi() {
  set_has_imsi();
  if (imsi_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    imsi_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ecu.lapi.pb.ModemSim.imsi)
  return imsi_;
}
inline ::std::string* ModemSim::release_imsi() {
  clear_has_imsi();
  if (imsi_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = imsi_;
    imsi_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ModemSim::set_allocated_imsi(::std::string* imsi) {
  if (imsi_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete imsi_;
  }
  if (imsi) {
    set_has_imsi();
    imsi_ = imsi;
  } else {
    clear_has_imsi();
    imsi_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ecu.lapi.pb.ModemSim.imsi)
}

// optional string iccid = 3;
inline bool ModemSim::has_iccid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ModemSim::set_has_iccid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ModemSim::clear_has_iccid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ModemSim::clear_iccid() {
  if (iccid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    iccid_->clear();
  }
  clear_has_iccid();
}
inline const ::std::string& ModemSim::iccid() const {
  // @@protoc_insertion_point(field_get:ecu.lapi.pb.ModemSim.iccid)
  return *iccid_;
}
inline void ModemSim::set_iccid(const ::std::string& value) {
  set_has_iccid();
  if (iccid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    iccid_ = new ::std::string;
  }
  iccid_->assign(value);
  // @@protoc_insertion_point(field_set:ecu.lapi.pb.ModemSim.iccid)
}
inline void ModemSim::set_iccid(const char* value) {
  set_has_iccid();
  if (iccid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    iccid_ = new ::std::string;
  }
  iccid_->assign(value);
  // @@protoc_insertion_point(field_set_char:ecu.lapi.pb.ModemSim.iccid)
}
inline void ModemSim::set_iccid(const char* value, size_t size) {
  set_has_iccid();
  if (iccid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    iccid_ = new ::std::string;
  }
  iccid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ecu.lapi.pb.ModemSim.iccid)
}
inline ::std::string* ModemSim::mutable_iccid() {
  set_has_iccid();
  if (iccid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    iccid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ecu.lapi.pb.ModemSim.iccid)
  return iccid_;
}
inline ::std::string* ModemSim::release_iccid() {
  clear_has_iccid();
  if (iccid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = iccid_;
    iccid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ModemSim::set_allocated_iccid(::std::string* iccid) {
  if (iccid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete iccid_;
  }
  if (iccid) {
    set_has_iccid();
    iccid_ = iccid;
  } else {
    clear_has_iccid();
    iccid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ecu.lapi.pb.ModemSim.iccid)
}

// -------------------------------------------------------------------

// ModemSimInformation

// optional .ecu.lapi.pb.ModemSim internal = 1;
inline bool ModemSimInformation::has_internal() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ModemSimInformation::set_has_internal() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ModemSimInformation::clear_has_internal() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ModemSimInformation::clear_internal() {
  if (internal_ != NULL) internal_->::ecu::lapi::pb::ModemSim::Clear();
  clear_has_internal();
}
inline const ::ecu::lapi::pb::ModemSim& ModemSimInformation::internal() const {
  // @@protoc_insertion_point(field_get:ecu.lapi.pb.ModemSimInformation.internal)
  return internal_ != NULL ? *internal_ : *default_instance_->internal_;
}
inline ::ecu::lapi::pb::ModemSim* ModemSimInformation::mutable_internal() {
  set_has_internal();
  if (internal_ == NULL) internal_ = new ::ecu::lapi::pb::ModemSim;
  // @@protoc_insertion_point(field_mutable:ecu.lapi.pb.ModemSimInformation.internal)
  return internal_;
}
inline ::ecu::lapi::pb::ModemSim* ModemSimInformation::release_internal() {
  clear_has_internal();
  ::ecu::lapi::pb::ModemSim* temp = internal_;
  internal_ = NULL;
  return temp;
}
inline void ModemSimInformation::set_allocated_internal(::ecu::lapi::pb::ModemSim* internal) {
  delete internal_;
  internal_ = internal;
  if (internal) {
    set_has_internal();
  } else {
    clear_has_internal();
  }
  // @@protoc_insertion_point(field_set_allocated:ecu.lapi.pb.ModemSimInformation.internal)
}

// optional .ecu.lapi.pb.ModemSim external = 2;
inline bool ModemSimInformation::has_external() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ModemSimInformation::set_has_external() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ModemSimInformation::clear_has_external() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ModemSimInformation::clear_external() {
  if (external_ != NULL) external_->::ecu::lapi::pb::ModemSim::Clear();
  clear_has_external();
}
inline const ::ecu::lapi::pb::ModemSim& ModemSimInformation::external() const {
  // @@protoc_insertion_point(field_get:ecu.lapi.pb.ModemSimInformation.external)
  return external_ != NULL ? *external_ : *default_instance_->external_;
}
inline ::ecu::lapi::pb::ModemSim* ModemSimInformation::mutable_external() {
  set_has_external();
  if (external_ == NULL) external_ = new ::ecu::lapi::pb::ModemSim;
  // @@protoc_insertion_point(field_mutable:ecu.lapi.pb.ModemSimInformation.external)
  return external_;
}
inline ::ecu::lapi::pb::ModemSim* ModemSimInformation::release_external() {
  clear_has_external();
  ::ecu::lapi::pb::ModemSim* temp = external_;
  external_ = NULL;
  return temp;
}
inline void ModemSimInformation::set_allocated_external(::ecu::lapi::pb::ModemSim* external) {
  delete external_;
  external_ = external;
  if (external) {
    set_has_external();
  } else {
    clear_has_external();
  }
  // @@protoc_insertion_point(field_set_allocated:ecu.lapi.pb.ModemSimInformation.external)
}

// optional .ecu.lapi.pb.ModemSimType active = 3;
inline bool ModemSimInformation::has_active() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ModemSimInformation::set_has_active() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ModemSimInformation::clear_has_active() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ModemSimInformation::clear_active() {
  active_ = 0;
  clear_has_active();
}
inline ::ecu::lapi::pb::ModemSimType ModemSimInformation::active() const {
  // @@protoc_insertion_point(field_get:ecu.lapi.pb.ModemSimInformation.active)
  return static_cast< ::ecu::lapi::pb::ModemSimType >(active_);
}
inline void ModemSimInformation::set_active(::ecu::lapi::pb::ModemSimType value) {
  assert(::ecu::lapi::pb::ModemSimType_IsValid(value));
  set_has_active();
  active_ = value;
  // @@protoc_insertion_point(field_set:ecu.lapi.pb.ModemSimInformation.active)
}

// -------------------------------------------------------------------

// ModemHardware

// optional string imei = 1;
inline bool ModemHardware::has_imei() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ModemHardware::set_has_imei() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ModemHardware::clear_has_imei() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ModemHardware::clear_imei() {
  if (imei_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    imei_->clear();
  }
  clear_has_imei();
}
inline const ::std::string& ModemHardware::imei() const {
  // @@protoc_insertion_point(field_get:ecu.lapi.pb.ModemHardware.imei)
  return *imei_;
}
inline void ModemHardware::set_imei(const ::std::string& value) {
  set_has_imei();
  if (imei_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    imei_ = new ::std::string;
  }
  imei_->assign(value);
  // @@protoc_insertion_point(field_set:ecu.lapi.pb.ModemHardware.imei)
}
inline void ModemHardware::set_imei(const char* value) {
  set_has_imei();
  if (imei_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    imei_ = new ::std::string;
  }
  imei_->assign(value);
  // @@protoc_insertion_point(field_set_char:ecu.lapi.pb.ModemHardware.imei)
}
inline void ModemHardware::set_imei(const char* value, size_t size) {
  set_has_imei();
  if (imei_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    imei_ = new ::std::string;
  }
  imei_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ecu.lapi.pb.ModemHardware.imei)
}
inline ::std::string* ModemHardware::mutable_imei() {
  set_has_imei();
  if (imei_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    imei_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ecu.lapi.pb.ModemHardware.imei)
  return imei_;
}
inline ::std::string* ModemHardware::release_imei() {
  clear_has_imei();
  if (imei_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = imei_;
    imei_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ModemHardware::set_allocated_imei(::std::string* imei) {
  if (imei_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete imei_;
  }
  if (imei) {
    set_has_imei();
    imei_ = imei;
  } else {
    clear_has_imei();
    imei_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ecu.lapi.pb.ModemHardware.imei)
}

// optional string manufacturer = 2;
inline bool ModemHardware::has_manufacturer() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ModemHardware::set_has_manufacturer() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ModemHardware::clear_has_manufacturer() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ModemHardware::clear_manufacturer() {
  if (manufacturer_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    manufacturer_->clear();
  }
  clear_has_manufacturer();
}
inline const ::std::string& ModemHardware::manufacturer() const {
  // @@protoc_insertion_point(field_get:ecu.lapi.pb.ModemHardware.manufacturer)
  return *manufacturer_;
}
inline void ModemHardware::set_manufacturer(const ::std::string& value) {
  set_has_manufacturer();
  if (manufacturer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    manufacturer_ = new ::std::string;
  }
  manufacturer_->assign(value);
  // @@protoc_insertion_point(field_set:ecu.lapi.pb.ModemHardware.manufacturer)
}
inline void ModemHardware::set_manufacturer(const char* value) {
  set_has_manufacturer();
  if (manufacturer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    manufacturer_ = new ::std::string;
  }
  manufacturer_->assign(value);
  // @@protoc_insertion_point(field_set_char:ecu.lapi.pb.ModemHardware.manufacturer)
}
inline void ModemHardware::set_manufacturer(const char* value, size_t size) {
  set_has_manufacturer();
  if (manufacturer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    manufacturer_ = new ::std::string;
  }
  manufacturer_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ecu.lapi.pb.ModemHardware.manufacturer)
}
inline ::std::string* ModemHardware::mutable_manufacturer() {
  set_has_manufacturer();
  if (manufacturer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    manufacturer_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ecu.lapi.pb.ModemHardware.manufacturer)
  return manufacturer_;
}
inline ::std::string* ModemHardware::release_manufacturer() {
  clear_has_manufacturer();
  if (manufacturer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = manufacturer_;
    manufacturer_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ModemHardware::set_allocated_manufacturer(::std::string* manufacturer) {
  if (manufacturer_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete manufacturer_;
  }
  if (manufacturer) {
    set_has_manufacturer();
    manufacturer_ = manufacturer;
  } else {
    clear_has_manufacturer();
    manufacturer_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ecu.lapi.pb.ModemHardware.manufacturer)
}

// optional string model = 3;
inline bool ModemHardware::has_model() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ModemHardware::set_has_model() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ModemHardware::clear_has_model() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ModemHardware::clear_model() {
  if (model_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    model_->clear();
  }
  clear_has_model();
}
inline const ::std::string& ModemHardware::model() const {
  // @@protoc_insertion_point(field_get:ecu.lapi.pb.ModemHardware.model)
  return *model_;
}
inline void ModemHardware::set_model(const ::std::string& value) {
  set_has_model();
  if (model_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    model_ = new ::std::string;
  }
  model_->assign(value);
  // @@protoc_insertion_point(field_set:ecu.lapi.pb.ModemHardware.model)
}
inline void ModemHardware::set_model(const char* value) {
  set_has_model();
  if (model_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    model_ = new ::std::string;
  }
  model_->assign(value);
  // @@protoc_insertion_point(field_set_char:ecu.lapi.pb.ModemHardware.model)
}
inline void ModemHardware::set_model(const char* value, size_t size) {
  set_has_model();
  if (model_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    model_ = new ::std::string;
  }
  model_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ecu.lapi.pb.ModemHardware.model)
}
inline ::std::string* ModemHardware::mutable_model() {
  set_has_model();
  if (model_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    model_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ecu.lapi.pb.ModemHardware.model)
  return model_;
}
inline ::std::string* ModemHardware::release_model() {
  clear_has_model();
  if (model_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = model_;
    model_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ModemHardware::set_allocated_model(::std::string* model) {
  if (model_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete model_;
  }
  if (model) {
    set_has_model();
    model_ = model;
  } else {
    clear_has_model();
    model_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ecu.lapi.pb.ModemHardware.model)
}

// -------------------------------------------------------------------

// ModemRegistration

// optional .ecu.lapi.pb.ModemRegistration.RadioAccessTechnology rat = 1;
inline bool ModemRegistration::has_rat() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ModemRegistration::set_has_rat() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ModemRegistration::clear_has_rat() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ModemRegistration::clear_rat() {
  rat_ = 0;
  clear_has_rat();
}
inline ::ecu::lapi::pb::ModemRegistration_RadioAccessTechnology ModemRegistration::rat() const {
  // @@protoc_insertion_point(field_get:ecu.lapi.pb.ModemRegistration.rat)
  return static_cast< ::ecu::lapi::pb::ModemRegistration_RadioAccessTechnology >(rat_);
}
inline void ModemRegistration::set_rat(::ecu::lapi::pb::ModemRegistration_RadioAccessTechnology value) {
  assert(::ecu::lapi::pb::ModemRegistration_RadioAccessTechnology_IsValid(value));
  set_has_rat();
  rat_ = value;
  // @@protoc_insertion_point(field_set:ecu.lapi.pb.ModemRegistration.rat)
}

// optional .ecu.lapi.pb.ModemRegistration.RegistrationStatus reg_status = 2;
inline bool ModemRegistration::has_reg_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ModemRegistration::set_has_reg_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ModemRegistration::clear_has_reg_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ModemRegistration::clear_reg_status() {
  reg_status_ = 0;
  clear_has_reg_status();
}
inline ::ecu::lapi::pb::ModemRegistration_RegistrationStatus ModemRegistration::reg_status() const {
  // @@protoc_insertion_point(field_get:ecu.lapi.pb.ModemRegistration.reg_status)
  return static_cast< ::ecu::lapi::pb::ModemRegistration_RegistrationStatus >(reg_status_);
}
inline void ModemRegistration::set_reg_status(::ecu::lapi::pb::ModemRegistration_RegistrationStatus value) {
  assert(::ecu::lapi::pb::ModemRegistration_RegistrationStatus_IsValid(value));
  set_has_reg_status();
  reg_status_ = value;
  // @@protoc_insertion_point(field_set:ecu.lapi.pb.ModemRegistration.reg_status)
}

// optional .ecu.lapi.pb.ModemRegistration.ExtPSRegStatus ps_reg_status = 3;
inline bool ModemRegistration::has_ps_reg_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ModemRegistration::set_has_ps_reg_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ModemRegistration::clear_has_ps_reg_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ModemRegistration::clear_ps_reg_status() {
  ps_reg_status_ = 0;
  clear_has_ps_reg_status();
}
inline ::ecu::lapi::pb::ModemRegistration_ExtPSRegStatus ModemRegistration::ps_reg_status() const {
  // @@protoc_insertion_point(field_get:ecu.lapi.pb.ModemRegistration.ps_reg_status)
  return static_cast< ::ecu::lapi::pb::ModemRegistration_ExtPSRegStatus >(ps_reg_status_);
}
inline void ModemRegistration::set_ps_reg_status(::ecu::lapi::pb::ModemRegistration_ExtPSRegStatus value) {
  assert(::ecu::lapi::pb::ModemRegistration_ExtPSRegStatus_IsValid(value));
  set_has_ps_reg_status();
  ps_reg_status_ = value;
  // @@protoc_insertion_point(field_set:ecu.lapi.pb.ModemRegistration.ps_reg_status)
}

// -------------------------------------------------------------------

// ModemLocation

// optional uint32 country_code = 1;
inline bool ModemLocation::has_country_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ModemLocation::set_has_country_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ModemLocation::clear_has_country_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ModemLocation::clear_country_code() {
  country_code_ = 0u;
  clear_has_country_code();
}
inline ::google::protobuf::uint32 ModemLocation::country_code() const {
  // @@protoc_insertion_point(field_get:ecu.lapi.pb.ModemLocation.country_code)
  return country_code_;
}
inline void ModemLocation::set_country_code(::google::protobuf::uint32 value) {
  set_has_country_code();
  country_code_ = value;
  // @@protoc_insertion_point(field_set:ecu.lapi.pb.ModemLocation.country_code)
}

// optional uint32 network_code = 2;
inline bool ModemLocation::has_network_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ModemLocation::set_has_network_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ModemLocation::clear_has_network_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ModemLocation::clear_network_code() {
  network_code_ = 0u;
  clear_has_network_code();
}
inline ::google::protobuf::uint32 ModemLocation::network_code() const {
  // @@protoc_insertion_point(field_get:ecu.lapi.pb.ModemLocation.network_code)
  return network_code_;
}
inline void ModemLocation::set_network_code(::google::protobuf::uint32 value) {
  set_has_network_code();
  network_code_ = value;
  // @@protoc_insertion_point(field_set:ecu.lapi.pb.ModemLocation.network_code)
}

// optional uint32 area_code = 3;
inline bool ModemLocation::has_area_code() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ModemLocation::set_has_area_code() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ModemLocation::clear_has_area_code() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ModemLocation::clear_area_code() {
  area_code_ = 0u;
  clear_has_area_code();
}
inline ::google::protobuf::uint32 ModemLocation::area_code() const {
  // @@protoc_insertion_point(field_get:ecu.lapi.pb.ModemLocation.area_code)
  return area_code_;
}
inline void ModemLocation::set_area_code(::google::protobuf::uint32 value) {
  set_has_area_code();
  area_code_ = value;
  // @@protoc_insertion_point(field_set:ecu.lapi.pb.ModemLocation.area_code)
}

// optional uint32 cell_id = 4;
inline bool ModemLocation::has_cell_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ModemLocation::set_has_cell_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ModemLocation::clear_has_cell_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ModemLocation::clear_cell_id() {
  cell_id_ = 0u;
  clear_has_cell_id();
}
inline ::google::protobuf::uint32 ModemLocation::cell_id() const {
  // @@protoc_insertion_point(field_get:ecu.lapi.pb.ModemLocation.cell_id)
  return cell_id_;
}
inline void ModemLocation::set_cell_id(::google::protobuf::uint32 value) {
  set_has_cell_id();
  cell_id_ = value;
  // @@protoc_insertion_point(field_set:ecu.lapi.pb.ModemLocation.cell_id)
}

// -------------------------------------------------------------------

// ModemStatus

// optional string modem_manufacturer = 1;
inline bool ModemStatus::has_modem_manufacturer() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ModemStatus::set_has_modem_manufacturer() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ModemStatus::clear_has_modem_manufacturer() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ModemStatus::clear_modem_manufacturer() {
  if (modem_manufacturer_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    modem_manufacturer_->clear();
  }
  clear_has_modem_manufacturer();
}
inline const ::std::string& ModemStatus::modem_manufacturer() const {
  // @@protoc_insertion_point(field_get:ecu.lapi.pb.ModemStatus.modem_manufacturer)
  return *modem_manufacturer_;
}
inline void ModemStatus::set_modem_manufacturer(const ::std::string& value) {
  set_has_modem_manufacturer();
  if (modem_manufacturer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    modem_manufacturer_ = new ::std::string;
  }
  modem_manufacturer_->assign(value);
  // @@protoc_insertion_point(field_set:ecu.lapi.pb.ModemStatus.modem_manufacturer)
}
inline void ModemStatus::set_modem_manufacturer(const char* value) {
  set_has_modem_manufacturer();
  if (modem_manufacturer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    modem_manufacturer_ = new ::std::string;
  }
  modem_manufacturer_->assign(value);
  // @@protoc_insertion_point(field_set_char:ecu.lapi.pb.ModemStatus.modem_manufacturer)
}
inline void ModemStatus::set_modem_manufacturer(const char* value, size_t size) {
  set_has_modem_manufacturer();
  if (modem_manufacturer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    modem_manufacturer_ = new ::std::string;
  }
  modem_manufacturer_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ecu.lapi.pb.ModemStatus.modem_manufacturer)
}
inline ::std::string* ModemStatus::mutable_modem_manufacturer() {
  set_has_modem_manufacturer();
  if (modem_manufacturer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    modem_manufacturer_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ecu.lapi.pb.ModemStatus.modem_manufacturer)
  return modem_manufacturer_;
}
inline ::std::string* ModemStatus::release_modem_manufacturer() {
  clear_has_modem_manufacturer();
  if (modem_manufacturer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = modem_manufacturer_;
    modem_manufacturer_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ModemStatus::set_allocated_modem_manufacturer(::std::string* modem_manufacturer) {
  if (modem_manufacturer_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete modem_manufacturer_;
  }
  if (modem_manufacturer) {
    set_has_modem_manufacturer();
    modem_manufacturer_ = modem_manufacturer;
  } else {
    clear_has_modem_manufacturer();
    modem_manufacturer_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ecu.lapi.pb.ModemStatus.modem_manufacturer)
}

// optional string modem_model = 2;
inline bool ModemStatus::has_modem_model() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ModemStatus::set_has_modem_model() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ModemStatus::clear_has_modem_model() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ModemStatus::clear_modem_model() {
  if (modem_model_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    modem_model_->clear();
  }
  clear_has_modem_model();
}
inline const ::std::string& ModemStatus::modem_model() const {
  // @@protoc_insertion_point(field_get:ecu.lapi.pb.ModemStatus.modem_model)
  return *modem_model_;
}
inline void ModemStatus::set_modem_model(const ::std::string& value) {
  set_has_modem_model();
  if (modem_model_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    modem_model_ = new ::std::string;
  }
  modem_model_->assign(value);
  // @@protoc_insertion_point(field_set:ecu.lapi.pb.ModemStatus.modem_model)
}
inline void ModemStatus::set_modem_model(const char* value) {
  set_has_modem_model();
  if (modem_model_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    modem_model_ = new ::std::string;
  }
  modem_model_->assign(value);
  // @@protoc_insertion_point(field_set_char:ecu.lapi.pb.ModemStatus.modem_model)
}
inline void ModemStatus::set_modem_model(const char* value, size_t size) {
  set_has_modem_model();
  if (modem_model_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    modem_model_ = new ::std::string;
  }
  modem_model_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ecu.lapi.pb.ModemStatus.modem_model)
}
inline ::std::string* ModemStatus::mutable_modem_model() {
  set_has_modem_model();
  if (modem_model_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    modem_model_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ecu.lapi.pb.ModemStatus.modem_model)
  return modem_model_;
}
inline ::std::string* ModemStatus::release_modem_model() {
  clear_has_modem_model();
  if (modem_model_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = modem_model_;
    modem_model_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ModemStatus::set_allocated_modem_model(::std::string* modem_model) {
  if (modem_model_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete modem_model_;
  }
  if (modem_model) {
    set_has_modem_model();
    modem_model_ = modem_model;
  } else {
    clear_has_modem_model();
    modem_model_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ecu.lapi.pb.ModemStatus.modem_model)
}

// optional .ecu.lapi.pb.ModemStatus.ModemState modem_state = 3;
inline bool ModemStatus::has_modem_state() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ModemStatus::set_has_modem_state() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ModemStatus::clear_has_modem_state() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ModemStatus::clear_modem_state() {
  modem_state_ = -1;
  clear_has_modem_state();
}
inline ::ecu::lapi::pb::ModemStatus_ModemState ModemStatus::modem_state() const {
  // @@protoc_insertion_point(field_get:ecu.lapi.pb.ModemStatus.modem_state)
  return static_cast< ::ecu::lapi::pb::ModemStatus_ModemState >(modem_state_);
}
inline void ModemStatus::set_modem_state(::ecu::lapi::pb::ModemStatus_ModemState value) {
  assert(::ecu::lapi::pb::ModemStatus_ModemState_IsValid(value));
  set_has_modem_state();
  modem_state_ = value;
  // @@protoc_insertion_point(field_set:ecu.lapi.pb.ModemStatus.modem_state)
}

// optional double signal_strength = 4;
inline bool ModemStatus::has_signal_strength() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ModemStatus::set_has_signal_strength() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ModemStatus::clear_has_signal_strength() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ModemStatus::clear_signal_strength() {
  signal_strength_ = 0;
  clear_has_signal_strength();
}
inline double ModemStatus::signal_strength() const {
  // @@protoc_insertion_point(field_get:ecu.lapi.pb.ModemStatus.signal_strength)
  return signal_strength_;
}
inline void ModemStatus::set_signal_strength(double value) {
  set_has_signal_strength();
  signal_strength_ = value;
  // @@protoc_insertion_point(field_set:ecu.lapi.pb.ModemStatus.signal_strength)
}

// optional double signal_quality = 5;
inline bool ModemStatus::has_signal_quality() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ModemStatus::set_has_signal_quality() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ModemStatus::clear_has_signal_quality() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ModemStatus::clear_signal_quality() {
  signal_quality_ = 0;
  clear_has_signal_quality();
}
inline double ModemStatus::signal_quality() const {
  // @@protoc_insertion_point(field_get:ecu.lapi.pb.ModemStatus.signal_quality)
  return signal_quality_;
}
inline void ModemStatus::set_signal_quality(double value) {
  set_has_signal_quality();
  signal_quality_ = value;
  // @@protoc_insertion_point(field_set:ecu.lapi.pb.ModemStatus.signal_quality)
}

// optional bool roaming = 6;
inline bool ModemStatus::has_roaming() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ModemStatus::set_has_roaming() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ModemStatus::clear_has_roaming() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ModemStatus::clear_roaming() {
  roaming_ = false;
  clear_has_roaming();
}
inline bool ModemStatus::roaming() const {
  // @@protoc_insertion_point(field_get:ecu.lapi.pb.ModemStatus.roaming)
  return roaming_;
}
inline void ModemStatus::set_roaming(bool value) {
  set_has_roaming();
  roaming_ = value;
  // @@protoc_insertion_point(field_set:ecu.lapi.pb.ModemStatus.roaming)
}

// optional fixed32 simple_access_bitmask = 7;
inline bool ModemStatus::has_simple_access_bitmask() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ModemStatus::set_has_simple_access_bitmask() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ModemStatus::clear_has_simple_access_bitmask() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ModemStatus::clear_simple_access_bitmask() {
  simple_access_bitmask_ = 0u;
  clear_has_simple_access_bitmask();
}
inline ::google::protobuf::uint32 ModemStatus::simple_access_bitmask() const {
  // @@protoc_insertion_point(field_get:ecu.lapi.pb.ModemStatus.simple_access_bitmask)
  return simple_access_bitmask_;
}
inline void ModemStatus::set_simple_access_bitmask(::google::protobuf::uint32 value) {
  set_has_simple_access_bitmask();
  simple_access_bitmask_ = value;
  // @@protoc_insertion_point(field_set:ecu.lapi.pb.ModemStatus.simple_access_bitmask)
}

// optional int32 simple_signal_quality = 8;
inline bool ModemStatus::has_simple_signal_quality() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ModemStatus::set_has_simple_signal_quality() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ModemStatus::clear_has_simple_signal_quality() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ModemStatus::clear_simple_signal_quality() {
  simple_signal_quality_ = 0;
  clear_has_simple_signal_quality();
}
inline ::google::protobuf::int32 ModemStatus::simple_signal_quality() const {
  // @@protoc_insertion_point(field_get:ecu.lapi.pb.ModemStatus.simple_signal_quality)
  return simple_signal_quality_;
}
inline void ModemStatus::set_simple_signal_quality(::google::protobuf::int32 value) {
  set_has_simple_signal_quality();
  simple_signal_quality_ = value;
  // @@protoc_insertion_point(field_set:ecu.lapi.pb.ModemStatus.simple_signal_quality)
}

// optional string sim_identifier = 9;
inline bool ModemStatus::has_sim_identifier() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ModemStatus::set_has_sim_identifier() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ModemStatus::clear_has_sim_identifier() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ModemStatus::clear_sim_identifier() {
  if (sim_identifier_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sim_identifier_->clear();
  }
  clear_has_sim_identifier();
}
inline const ::std::string& ModemStatus::sim_identifier() const {
  // @@protoc_insertion_point(field_get:ecu.lapi.pb.ModemStatus.sim_identifier)
  return *sim_identifier_;
}
inline void ModemStatus::set_sim_identifier(const ::std::string& value) {
  set_has_sim_identifier();
  if (sim_identifier_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sim_identifier_ = new ::std::string;
  }
  sim_identifier_->assign(value);
  // @@protoc_insertion_point(field_set:ecu.lapi.pb.ModemStatus.sim_identifier)
}
inline void ModemStatus::set_sim_identifier(const char* value) {
  set_has_sim_identifier();
  if (sim_identifier_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sim_identifier_ = new ::std::string;
  }
  sim_identifier_->assign(value);
  // @@protoc_insertion_point(field_set_char:ecu.lapi.pb.ModemStatus.sim_identifier)
}
inline void ModemStatus::set_sim_identifier(const char* value, size_t size) {
  set_has_sim_identifier();
  if (sim_identifier_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sim_identifier_ = new ::std::string;
  }
  sim_identifier_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ecu.lapi.pb.ModemStatus.sim_identifier)
}
inline ::std::string* ModemStatus::mutable_sim_identifier() {
  set_has_sim_identifier();
  if (sim_identifier_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sim_identifier_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ecu.lapi.pb.ModemStatus.sim_identifier)
  return sim_identifier_;
}
inline ::std::string* ModemStatus::release_sim_identifier() {
  clear_has_sim_identifier();
  if (sim_identifier_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = sim_identifier_;
    sim_identifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ModemStatus::set_allocated_sim_identifier(::std::string* sim_identifier) {
  if (sim_identifier_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete sim_identifier_;
  }
  if (sim_identifier) {
    set_has_sim_identifier();
    sim_identifier_ = sim_identifier;
  } else {
    clear_has_sim_identifier();
    sim_identifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ecu.lapi.pb.ModemStatus.sim_identifier)
}

// optional string sim_imsi = 10;
inline bool ModemStatus::has_sim_imsi() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ModemStatus::set_has_sim_imsi() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ModemStatus::clear_has_sim_imsi() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ModemStatus::clear_sim_imsi() {
  if (sim_imsi_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sim_imsi_->clear();
  }
  clear_has_sim_imsi();
}
inline const ::std::string& ModemStatus::sim_imsi() const {
  // @@protoc_insertion_point(field_get:ecu.lapi.pb.ModemStatus.sim_imsi)
  return *sim_imsi_;
}
inline void ModemStatus::set_sim_imsi(const ::std::string& value) {
  set_has_sim_imsi();
  if (sim_imsi_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sim_imsi_ = new ::std::string;
  }
  sim_imsi_->assign(value);
  // @@protoc_insertion_point(field_set:ecu.lapi.pb.ModemStatus.sim_imsi)
}
inline void ModemStatus::set_sim_imsi(const char* value) {
  set_has_sim_imsi();
  if (sim_imsi_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sim_imsi_ = new ::std::string;
  }
  sim_imsi_->assign(value);
  // @@protoc_insertion_point(field_set_char:ecu.lapi.pb.ModemStatus.sim_imsi)
}
inline void ModemStatus::set_sim_imsi(const char* value, size_t size) {
  set_has_sim_imsi();
  if (sim_imsi_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sim_imsi_ = new ::std::string;
  }
  sim_imsi_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ecu.lapi.pb.ModemStatus.sim_imsi)
}
inline ::std::string* ModemStatus::mutable_sim_imsi() {
  set_has_sim_imsi();
  if (sim_imsi_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sim_imsi_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ecu.lapi.pb.ModemStatus.sim_imsi)
  return sim_imsi_;
}
inline ::std::string* ModemStatus::release_sim_imsi() {
  clear_has_sim_imsi();
  if (sim_imsi_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = sim_imsi_;
    sim_imsi_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ModemStatus::set_allocated_sim_imsi(::std::string* sim_imsi) {
  if (sim_imsi_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete sim_imsi_;
  }
  if (sim_imsi) {
    set_has_sim_imsi();
    sim_imsi_ = sim_imsi;
  } else {
    clear_has_sim_imsi();
    sim_imsi_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ecu.lapi.pb.ModemStatus.sim_imsi)
}

// optional string sim_operator_name = 11;
inline bool ModemStatus::has_sim_operator_name() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ModemStatus::set_has_sim_operator_name() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ModemStatus::clear_has_sim_operator_name() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ModemStatus::clear_sim_operator_name() {
  if (sim_operator_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sim_operator_name_->clear();
  }
  clear_has_sim_operator_name();
}
inline const ::std::string& ModemStatus::sim_operator_name() const {
  // @@protoc_insertion_point(field_get:ecu.lapi.pb.ModemStatus.sim_operator_name)
  return *sim_operator_name_;
}
inline void ModemStatus::set_sim_operator_name(const ::std::string& value) {
  set_has_sim_operator_name();
  if (sim_operator_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sim_operator_name_ = new ::std::string;
  }
  sim_operator_name_->assign(value);
  // @@protoc_insertion_point(field_set:ecu.lapi.pb.ModemStatus.sim_operator_name)
}
inline void ModemStatus::set_sim_operator_name(const char* value) {
  set_has_sim_operator_name();
  if (sim_operator_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sim_operator_name_ = new ::std::string;
  }
  sim_operator_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:ecu.lapi.pb.ModemStatus.sim_operator_name)
}
inline void ModemStatus::set_sim_operator_name(const char* value, size_t size) {
  set_has_sim_operator_name();
  if (sim_operator_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sim_operator_name_ = new ::std::string;
  }
  sim_operator_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ecu.lapi.pb.ModemStatus.sim_operator_name)
}
inline ::std::string* ModemStatus::mutable_sim_operator_name() {
  set_has_sim_operator_name();
  if (sim_operator_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sim_operator_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ecu.lapi.pb.ModemStatus.sim_operator_name)
  return sim_operator_name_;
}
inline ::std::string* ModemStatus::release_sim_operator_name() {
  clear_has_sim_operator_name();
  if (sim_operator_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = sim_operator_name_;
    sim_operator_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ModemStatus::set_allocated_sim_operator_name(::std::string* sim_operator_name) {
  if (sim_operator_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete sim_operator_name_;
  }
  if (sim_operator_name) {
    set_has_sim_operator_name();
    sim_operator_name_ = sim_operator_name;
  } else {
    clear_has_sim_operator_name();
    sim_operator_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ecu.lapi.pb.ModemStatus.sim_operator_name)
}

// optional bool sim_active = 12;
inline bool ModemStatus::has_sim_active() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ModemStatus::set_has_sim_active() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ModemStatus::clear_has_sim_active() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ModemStatus::clear_sim_active() {
  sim_active_ = false;
  clear_has_sim_active();
}
inline bool ModemStatus::sim_active() const {
  // @@protoc_insertion_point(field_get:ecu.lapi.pb.ModemStatus.sim_active)
  return sim_active_;
}
inline void ModemStatus::set_sim_active(bool value) {
  set_has_sim_active();
  sim_active_ = value;
  // @@protoc_insertion_point(field_set:ecu.lapi.pb.ModemStatus.sim_active)
}

// optional string operator_identifier = 13;
inline bool ModemStatus::has_operator_identifier() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ModemStatus::set_has_operator_identifier() {
  _has_bits_[0] |= 0x00001000u;
}
inline void ModemStatus::clear_has_operator_identifier() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void ModemStatus::clear_operator_identifier() {
  if (operator_identifier_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    operator_identifier_->clear();
  }
  clear_has_operator_identifier();
}
inline const ::std::string& ModemStatus::operator_identifier() const {
  // @@protoc_insertion_point(field_get:ecu.lapi.pb.ModemStatus.operator_identifier)
  return *operator_identifier_;
}
inline void ModemStatus::set_operator_identifier(const ::std::string& value) {
  set_has_operator_identifier();
  if (operator_identifier_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    operator_identifier_ = new ::std::string;
  }
  operator_identifier_->assign(value);
  // @@protoc_insertion_point(field_set:ecu.lapi.pb.ModemStatus.operator_identifier)
}
inline void ModemStatus::set_operator_identifier(const char* value) {
  set_has_operator_identifier();
  if (operator_identifier_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    operator_identifier_ = new ::std::string;
  }
  operator_identifier_->assign(value);
  // @@protoc_insertion_point(field_set_char:ecu.lapi.pb.ModemStatus.operator_identifier)
}
inline void ModemStatus::set_operator_identifier(const char* value, size_t size) {
  set_has_operator_identifier();
  if (operator_identifier_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    operator_identifier_ = new ::std::string;
  }
  operator_identifier_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ecu.lapi.pb.ModemStatus.operator_identifier)
}
inline ::std::string* ModemStatus::mutable_operator_identifier() {
  set_has_operator_identifier();
  if (operator_identifier_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    operator_identifier_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ecu.lapi.pb.ModemStatus.operator_identifier)
  return operator_identifier_;
}
inline ::std::string* ModemStatus::release_operator_identifier() {
  clear_has_operator_identifier();
  if (operator_identifier_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = operator_identifier_;
    operator_identifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ModemStatus::set_allocated_operator_identifier(::std::string* operator_identifier) {
  if (operator_identifier_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete operator_identifier_;
  }
  if (operator_identifier) {
    set_has_operator_identifier();
    operator_identifier_ = operator_identifier;
  } else {
    clear_has_operator_identifier();
    operator_identifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ecu.lapi.pb.ModemStatus.operator_identifier)
}

// optional string operator_name = 14;
inline bool ModemStatus::has_operator_name() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void ModemStatus::set_has_operator_name() {
  _has_bits_[0] |= 0x00002000u;
}
inline void ModemStatus::clear_has_operator_name() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void ModemStatus::clear_operator_name() {
  if (operator_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    operator_name_->clear();
  }
  clear_has_operator_name();
}
inline const ::std::string& ModemStatus::operator_name() const {
  // @@protoc_insertion_point(field_get:ecu.lapi.pb.ModemStatus.operator_name)
  return *operator_name_;
}
inline void ModemStatus::set_operator_name(const ::std::string& value) {
  set_has_operator_name();
  if (operator_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    operator_name_ = new ::std::string;
  }
  operator_name_->assign(value);
  // @@protoc_insertion_point(field_set:ecu.lapi.pb.ModemStatus.operator_name)
}
inline void ModemStatus::set_operator_name(const char* value) {
  set_has_operator_name();
  if (operator_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    operator_name_ = new ::std::string;
  }
  operator_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:ecu.lapi.pb.ModemStatus.operator_name)
}
inline void ModemStatus::set_operator_name(const char* value, size_t size) {
  set_has_operator_name();
  if (operator_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    operator_name_ = new ::std::string;
  }
  operator_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ecu.lapi.pb.ModemStatus.operator_name)
}
inline ::std::string* ModemStatus::mutable_operator_name() {
  set_has_operator_name();
  if (operator_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    operator_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ecu.lapi.pb.ModemStatus.operator_name)
  return operator_name_;
}
inline ::std::string* ModemStatus::release_operator_name() {
  clear_has_operator_name();
  if (operator_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = operator_name_;
    operator_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ModemStatus::set_allocated_operator_name(::std::string* operator_name) {
  if (operator_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete operator_name_;
  }
  if (operator_name) {
    set_has_operator_name();
    operator_name_ = operator_name;
  } else {
    clear_has_operator_name();
    operator_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ecu.lapi.pb.ModemStatus.operator_name)
}

// optional string imei = 15;
inline bool ModemStatus::has_imei() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void ModemStatus::set_has_imei() {
  _has_bits_[0] |= 0x00004000u;
}
inline void ModemStatus::clear_has_imei() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void ModemStatus::clear_imei() {
  if (imei_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    imei_->clear();
  }
  clear_has_imei();
}
inline const ::std::string& ModemStatus::imei() const {
  // @@protoc_insertion_point(field_get:ecu.lapi.pb.ModemStatus.imei)
  return *imei_;
}
inline void ModemStatus::set_imei(const ::std::string& value) {
  set_has_imei();
  if (imei_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    imei_ = new ::std::string;
  }
  imei_->assign(value);
  // @@protoc_insertion_point(field_set:ecu.lapi.pb.ModemStatus.imei)
}
inline void ModemStatus::set_imei(const char* value) {
  set_has_imei();
  if (imei_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    imei_ = new ::std::string;
  }
  imei_->assign(value);
  // @@protoc_insertion_point(field_set_char:ecu.lapi.pb.ModemStatus.imei)
}
inline void ModemStatus::set_imei(const char* value, size_t size) {
  set_has_imei();
  if (imei_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    imei_ = new ::std::string;
  }
  imei_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ecu.lapi.pb.ModemStatus.imei)
}
inline ::std::string* ModemStatus::mutable_imei() {
  set_has_imei();
  if (imei_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    imei_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ecu.lapi.pb.ModemStatus.imei)
  return imei_;
}
inline ::std::string* ModemStatus::release_imei() {
  clear_has_imei();
  if (imei_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = imei_;
    imei_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ModemStatus::set_allocated_imei(::std::string* imei) {
  if (imei_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete imei_;
  }
  if (imei) {
    set_has_imei();
    imei_ = imei;
  } else {
    clear_has_imei();
    imei_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ecu.lapi.pb.ModemStatus.imei)
}

// optional .ecu.lapi.pb.ModemLocation location = 16;
inline bool ModemStatus::has_location() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void ModemStatus::set_has_location() {
  _has_bits_[0] |= 0x00008000u;
}
inline void ModemStatus::clear_has_location() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void ModemStatus::clear_location() {
  if (location_ != NULL) location_->::ecu::lapi::pb::ModemLocation::Clear();
  clear_has_location();
}
inline const ::ecu::lapi::pb::ModemLocation& ModemStatus::location() const {
  // @@protoc_insertion_point(field_get:ecu.lapi.pb.ModemStatus.location)
  return location_ != NULL ? *location_ : *default_instance_->location_;
}
inline ::ecu::lapi::pb::ModemLocation* ModemStatus::mutable_location() {
  set_has_location();
  if (location_ == NULL) location_ = new ::ecu::lapi::pb::ModemLocation;
  // @@protoc_insertion_point(field_mutable:ecu.lapi.pb.ModemStatus.location)
  return location_;
}
inline ::ecu::lapi::pb::ModemLocation* ModemStatus::release_location() {
  clear_has_location();
  ::ecu::lapi::pb::ModemLocation* temp = location_;
  location_ = NULL;
  return temp;
}
inline void ModemStatus::set_allocated_location(::ecu::lapi::pb::ModemLocation* location) {
  delete location_;
  location_ = location;
  if (location) {
    set_has_location();
  } else {
    clear_has_location();
  }
  // @@protoc_insertion_point(field_set_allocated:ecu.lapi.pb.ModemStatus.location)
}

// optional uint64 network_utc_time = 17;
inline bool ModemStatus::has_network_utc_time() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void ModemStatus::set_has_network_utc_time() {
  _has_bits_[0] |= 0x00010000u;
}
inline void ModemStatus::clear_has_network_utc_time() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void ModemStatus::clear_network_utc_time() {
  network_utc_time_ = GOOGLE_ULONGLONG(0);
  clear_has_network_utc_time();
}
inline ::google::protobuf::uint64 ModemStatus::network_utc_time() const {
  // @@protoc_insertion_point(field_get:ecu.lapi.pb.ModemStatus.network_utc_time)
  return network_utc_time_;
}
inline void ModemStatus::set_network_utc_time(::google::protobuf::uint64 value) {
  set_has_network_utc_time();
  network_utc_time_ = value;
  // @@protoc_insertion_point(field_set:ecu.lapi.pb.ModemStatus.network_utc_time)
}

// optional uint64 timestamp_ns = 18;
inline bool ModemStatus::has_timestamp_ns() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void ModemStatus::set_has_timestamp_ns() {
  _has_bits_[0] |= 0x00020000u;
}
inline void ModemStatus::clear_has_timestamp_ns() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void ModemStatus::clear_timestamp_ns() {
  timestamp_ns_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp_ns();
}
inline ::google::protobuf::uint64 ModemStatus::timestamp_ns() const {
  // @@protoc_insertion_point(field_get:ecu.lapi.pb.ModemStatus.timestamp_ns)
  return timestamp_ns_;
}
inline void ModemStatus::set_timestamp_ns(::google::protobuf::uint64 value) {
  set_has_timestamp_ns();
  timestamp_ns_ = value;
  // @@protoc_insertion_point(field_set:ecu.lapi.pb.ModemStatus.timestamp_ns)
}

// optional .ecu.lapi.pb.ModemStatus.ModemResetReason reset_reason = 19;
inline bool ModemStatus::has_reset_reason() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void ModemStatus::set_has_reset_reason() {
  _has_bits_[0] |= 0x00040000u;
}
inline void ModemStatus::clear_has_reset_reason() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void ModemStatus::clear_reset_reason() {
  reset_reason_ = 0;
  clear_has_reset_reason();
}
inline ::ecu::lapi::pb::ModemStatus_ModemResetReason ModemStatus::reset_reason() const {
  // @@protoc_insertion_point(field_get:ecu.lapi.pb.ModemStatus.reset_reason)
  return static_cast< ::ecu::lapi::pb::ModemStatus_ModemResetReason >(reset_reason_);
}
inline void ModemStatus::set_reset_reason(::ecu::lapi::pb::ModemStatus_ModemResetReason value) {
  assert(::ecu::lapi::pb::ModemStatus_ModemResetReason_IsValid(value));
  set_has_reset_reason();
  reset_reason_ = value;
  // @@protoc_insertion_point(field_set:ecu.lapi.pb.ModemStatus.reset_reason)
}

// -------------------------------------------------------------------

// ModemSms

// optional string number = 1;
inline bool ModemSms::has_number() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ModemSms::set_has_number() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ModemSms::clear_has_number() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ModemSms::clear_number() {
  if (number_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    number_->clear();
  }
  clear_has_number();
}
inline const ::std::string& ModemSms::number() const {
  // @@protoc_insertion_point(field_get:ecu.lapi.pb.ModemSms.number)
  return *number_;
}
inline void ModemSms::set_number(const ::std::string& value) {
  set_has_number();
  if (number_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    number_ = new ::std::string;
  }
  number_->assign(value);
  // @@protoc_insertion_point(field_set:ecu.lapi.pb.ModemSms.number)
}
inline void ModemSms::set_number(const char* value) {
  set_has_number();
  if (number_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    number_ = new ::std::string;
  }
  number_->assign(value);
  // @@protoc_insertion_point(field_set_char:ecu.lapi.pb.ModemSms.number)
}
inline void ModemSms::set_number(const char* value, size_t size) {
  set_has_number();
  if (number_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    number_ = new ::std::string;
  }
  number_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ecu.lapi.pb.ModemSms.number)
}
inline ::std::string* ModemSms::mutable_number() {
  set_has_number();
  if (number_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    number_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ecu.lapi.pb.ModemSms.number)
  return number_;
}
inline ::std::string* ModemSms::release_number() {
  clear_has_number();
  if (number_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = number_;
    number_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ModemSms::set_allocated_number(::std::string* number) {
  if (number_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete number_;
  }
  if (number) {
    set_has_number();
    number_ = number;
  } else {
    clear_has_number();
    number_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ecu.lapi.pb.ModemSms.number)
}

// optional string timestamp = 2;
inline bool ModemSms::has_timestamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ModemSms::set_has_timestamp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ModemSms::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ModemSms::clear_timestamp() {
  if (timestamp_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    timestamp_->clear();
  }
  clear_has_timestamp();
}
inline const ::std::string& ModemSms::timestamp() const {
  // @@protoc_insertion_point(field_get:ecu.lapi.pb.ModemSms.timestamp)
  return *timestamp_;
}
inline void ModemSms::set_timestamp(const ::std::string& value) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(value);
  // @@protoc_insertion_point(field_set:ecu.lapi.pb.ModemSms.timestamp)
}
inline void ModemSms::set_timestamp(const char* value) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(value);
  // @@protoc_insertion_point(field_set_char:ecu.lapi.pb.ModemSms.timestamp)
}
inline void ModemSms::set_timestamp(const char* value, size_t size) {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    timestamp_ = new ::std::string;
  }
  timestamp_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ecu.lapi.pb.ModemSms.timestamp)
}
inline ::std::string* ModemSms::mutable_timestamp() {
  set_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    timestamp_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ecu.lapi.pb.ModemSms.timestamp)
  return timestamp_;
}
inline ::std::string* ModemSms::release_timestamp() {
  clear_has_timestamp();
  if (timestamp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = timestamp_;
    timestamp_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ModemSms::set_allocated_timestamp(::std::string* timestamp) {
  if (timestamp_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete timestamp_;
  }
  if (timestamp) {
    set_has_timestamp();
    timestamp_ = timestamp;
  } else {
    clear_has_timestamp();
    timestamp_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ecu.lapi.pb.ModemSms.timestamp)
}

// optional string content = 3;
inline bool ModemSms::has_content() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ModemSms::set_has_content() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ModemSms::clear_has_content() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ModemSms::clear_content() {
  if (content_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& ModemSms::content() const {
  // @@protoc_insertion_point(field_get:ecu.lapi.pb.ModemSms.content)
  return *content_;
}
inline void ModemSms::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(value);
  // @@protoc_insertion_point(field_set:ecu.lapi.pb.ModemSms.content)
}
inline void ModemSms::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(value);
  // @@protoc_insertion_point(field_set_char:ecu.lapi.pb.ModemSms.content)
}
inline void ModemSms::set_content(const char* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ecu.lapi.pb.ModemSms.content)
}
inline ::std::string* ModemSms::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ecu.lapi.pb.ModemSms.content)
  return content_;
}
inline ::std::string* ModemSms::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ModemSms::set_allocated_content(::std::string* content) {
  if (content_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete content_;
  }
  if (content) {
    set_has_content();
    content_ = content;
  } else {
    clear_has_content();
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ecu.lapi.pb.ModemSms.content)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb
}  // namespace lapi
}  // namespace ecu

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::ecu::lapi::pb::ModemRegistration_RegistrationStatus> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ecu::lapi::pb::ModemRegistration_RegistrationStatus>() {
  return ::ecu::lapi::pb::ModemRegistration_RegistrationStatus_descriptor();
}
template <> struct is_proto_enum< ::ecu::lapi::pb::ModemRegistration_RadioAccessTechnology> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ecu::lapi::pb::ModemRegistration_RadioAccessTechnology>() {
  return ::ecu::lapi::pb::ModemRegistration_RadioAccessTechnology_descriptor();
}
template <> struct is_proto_enum< ::ecu::lapi::pb::ModemRegistration_ExtPSRegStatus> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ecu::lapi::pb::ModemRegistration_ExtPSRegStatus>() {
  return ::ecu::lapi::pb::ModemRegistration_ExtPSRegStatus_descriptor();
}
template <> struct is_proto_enum< ::ecu::lapi::pb::ModemStatus_ModemState> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ecu::lapi::pb::ModemStatus_ModemState>() {
  return ::ecu::lapi::pb::ModemStatus_ModemState_descriptor();
}
template <> struct is_proto_enum< ::ecu::lapi::pb::ModemStatus_AccessTechnology> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ecu::lapi::pb::ModemStatus_AccessTechnology>() {
  return ::ecu::lapi::pb::ModemStatus_AccessTechnology_descriptor();
}
template <> struct is_proto_enum< ::ecu::lapi::pb::ModemStatus_ModemResetReason> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ecu::lapi::pb::ModemStatus_ModemResetReason>() {
  return ::ecu::lapi::pb::ModemStatus_ModemResetReason_descriptor();
}
template <> struct is_proto_enum< ::ecu::lapi::pb::ModemSimType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ecu::lapi::pb::ModemSimType>() {
  return ::ecu::lapi::pb::ModemSimType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_modem_2eproto__INCLUDED
