// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: modem.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "modem.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace ecu {
namespace lapi {
namespace pb {

namespace {

const ::google::protobuf::Descriptor* ModemSim_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ModemSim_reflection_ = NULL;
const ::google::protobuf::Descriptor* ModemSimInformation_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ModemSimInformation_reflection_ = NULL;
const ::google::protobuf::Descriptor* ModemHardware_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ModemHardware_reflection_ = NULL;
const ::google::protobuf::Descriptor* ModemRegistration_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ModemRegistration_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* ModemRegistration_RegistrationStatus_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* ModemRegistration_RadioAccessTechnology_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* ModemRegistration_ExtPSRegStatus_descriptor_ = NULL;
const ::google::protobuf::Descriptor* ModemLocation_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ModemLocation_reflection_ = NULL;
const ::google::protobuf::Descriptor* ModemStatus_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ModemStatus_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* ModemStatus_ModemState_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* ModemStatus_AccessTechnology_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* ModemStatus_ModemResetReason_descriptor_ = NULL;
const ::google::protobuf::Descriptor* ModemSms_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ModemSms_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* ModemSimType_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_modem_2eproto() {
  protobuf_AddDesc_modem_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "modem.proto");
  GOOGLE_CHECK(file != NULL);
  ModemSim_descriptor_ = file->message_type(0);
  static const int ModemSim_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModemSim, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModemSim, imsi_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModemSim, iccid_),
  };
  ModemSim_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ModemSim_descriptor_,
      ModemSim::default_instance_,
      ModemSim_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModemSim, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModemSim, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ModemSim));
  ModemSimInformation_descriptor_ = file->message_type(1);
  static const int ModemSimInformation_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModemSimInformation, internal_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModemSimInformation, external_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModemSimInformation, active_),
  };
  ModemSimInformation_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ModemSimInformation_descriptor_,
      ModemSimInformation::default_instance_,
      ModemSimInformation_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModemSimInformation, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModemSimInformation, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ModemSimInformation));
  ModemHardware_descriptor_ = file->message_type(2);
  static const int ModemHardware_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModemHardware, imei_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModemHardware, manufacturer_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModemHardware, model_),
  };
  ModemHardware_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ModemHardware_descriptor_,
      ModemHardware::default_instance_,
      ModemHardware_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModemHardware, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModemHardware, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ModemHardware));
  ModemRegistration_descriptor_ = file->message_type(3);
  static const int ModemRegistration_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModemRegistration, rat_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModemRegistration, reg_status_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModemRegistration, ps_reg_status_),
  };
  ModemRegistration_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ModemRegistration_descriptor_,
      ModemRegistration::default_instance_,
      ModemRegistration_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModemRegistration, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModemRegistration, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ModemRegistration));
  ModemRegistration_RegistrationStatus_descriptor_ = ModemRegistration_descriptor_->enum_type(0);
  ModemRegistration_RadioAccessTechnology_descriptor_ = ModemRegistration_descriptor_->enum_type(1);
  ModemRegistration_ExtPSRegStatus_descriptor_ = ModemRegistration_descriptor_->enum_type(2);
  ModemLocation_descriptor_ = file->message_type(4);
  static const int ModemLocation_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModemLocation, country_code_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModemLocation, network_code_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModemLocation, area_code_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModemLocation, cell_id_),
  };
  ModemLocation_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ModemLocation_descriptor_,
      ModemLocation::default_instance_,
      ModemLocation_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModemLocation, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModemLocation, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ModemLocation));
  ModemStatus_descriptor_ = file->message_type(5);
  static const int ModemStatus_offsets_[19] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModemStatus, modem_manufacturer_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModemStatus, modem_model_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModemStatus, modem_state_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModemStatus, signal_strength_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModemStatus, signal_quality_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModemStatus, roaming_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModemStatus, simple_access_bitmask_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModemStatus, simple_signal_quality_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModemStatus, sim_identifier_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModemStatus, sim_imsi_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModemStatus, sim_operator_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModemStatus, sim_active_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModemStatus, operator_identifier_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModemStatus, operator_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModemStatus, imei_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModemStatus, location_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModemStatus, network_utc_time_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModemStatus, timestamp_ns_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModemStatus, reset_reason_),
  };
  ModemStatus_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ModemStatus_descriptor_,
      ModemStatus::default_instance_,
      ModemStatus_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModemStatus, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModemStatus, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ModemStatus));
  ModemStatus_ModemState_descriptor_ = ModemStatus_descriptor_->enum_type(0);
  ModemStatus_AccessTechnology_descriptor_ = ModemStatus_descriptor_->enum_type(1);
  ModemStatus_ModemResetReason_descriptor_ = ModemStatus_descriptor_->enum_type(2);
  ModemSms_descriptor_ = file->message_type(6);
  static const int ModemSms_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModemSms, number_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModemSms, timestamp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModemSms, content_),
  };
  ModemSms_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ModemSms_descriptor_,
      ModemSms::default_instance_,
      ModemSms_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModemSms, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ModemSms, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ModemSms));
  ModemSimType_descriptor_ = file->enum_type(0);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_modem_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ModemSim_descriptor_, &ModemSim::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ModemSimInformation_descriptor_, &ModemSimInformation::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ModemHardware_descriptor_, &ModemHardware::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ModemRegistration_descriptor_, &ModemRegistration::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ModemLocation_descriptor_, &ModemLocation::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ModemStatus_descriptor_, &ModemStatus::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ModemSms_descriptor_, &ModemSms::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_modem_2eproto() {
  delete ModemSim::default_instance_;
  delete ModemSim_reflection_;
  delete ModemSimInformation::default_instance_;
  delete ModemSimInformation_reflection_;
  delete ModemHardware::default_instance_;
  delete ModemHardware_reflection_;
  delete ModemRegistration::default_instance_;
  delete ModemRegistration_reflection_;
  delete ModemLocation::default_instance_;
  delete ModemLocation_reflection_;
  delete ModemStatus::default_instance_;
  delete ModemStatus_reflection_;
  delete ModemSms::default_instance_;
  delete ModemSms_reflection_;
}

void protobuf_AddDesc_modem_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\013modem.proto\022\013ecu.lapi.pb\"P\n\010ModemSim\022\'"
    "\n\004type\030\001 \001(\0162\031.ecu.lapi.pb.ModemSimType\022"
    "\014\n\004imsi\030\002 \001(\t\022\r\n\005iccid\030\003 \001(\t\"\222\001\n\023ModemSi"
    "mInformation\022\'\n\010internal\030\001 \001(\0132\025.ecu.lap"
    "i.pb.ModemSim\022\'\n\010external\030\002 \001(\0132\025.ecu.la"
    "pi.pb.ModemSim\022)\n\006active\030\003 \001(\0162\031.ecu.lap"
    "i.pb.ModemSimType\"B\n\rModemHardware\022\014\n\004im"
    "ei\030\001 \001(\t\022\024\n\014manufacturer\030\002 \001(\t\022\r\n\005model\030"
    "\003 \001(\t\"\302\006\n\021ModemRegistration\022A\n\003rat\030\001 \001(\016"
    "24.ecu.lapi.pb.ModemRegistration.RadioAc"
    "cessTechnology\022E\n\nreg_status\030\002 \001(\01621.ecu"
    ".lapi.pb.ModemRegistration.RegistrationS"
    "tatus\022D\n\rps_reg_status\030\003 \001(\0162-.ecu.lapi."
    "pb.ModemRegistration.ExtPSRegStatus\"\324\001\n\022"
    "RegistrationStatus\022\016\n\nRS_NOT_SET\020\000\022\r\n\tRS"
    "_NOTREG\020\001\022\013\n\007RS_HOME\020\002\022\r\n\tRS_SEARCH\020\003\022\r\n"
    "\tRS_DENIED\020\004\022\016\n\nRS_UNKNOWN\020\005\022\016\n\nRS_ROAMI"
    "NG\020\006\022\016\n\nRS_SMSHOME\020\007\022\016\n\nRS_SMSROAM\020\010\022\020\n\014"
    "RS_EMERGENCY\020\t\022\020\n\014RS_NCSFBHOME\020\n\022\020\n\014RS_N"
    "CSFBROAM\020\013\"\265\001\n\025RadioAccessTechnology\022\017\n\013"
    "RAT_NOT_SET\020\000\022\013\n\007RAT_GSM\020\001\022\014\n\010RAT_GSMC\020\002"
    "\022\r\n\tRAT_UTRAN\020\003\022\017\n\013RAT_GSMEDGE\020\004\022\016\n\nRAT_"
    "UTRAND\020\005\022\016\n\nRAT_UTRANU\020\006\022\017\n\013RAT_UTRANDU\020"
    "\007\022\016\n\nRAT_EUTRAN\020\010\022\017\n\013RAT_INVALID\020\t\"\315\001\n\016E"
    "xtPSRegStatus\022\021\n\rEPSRS_NOT_SET\020\000\022\016\n\nEPSR"
    "S_NONE\020\001\022\016\n\nEPSRS_GPRS\020\002\022\016\n\nEPSRS_EDGE\020\003"
    "\022\017\n\013EPSRS_WCDMA\020\004\022\017\n\013EPSRS_HSDPA\020\005\022\017\n\013EP"
    "SRS_HSUPA\020\006\022\020\n\014EPSRS_HSDUPA\020\007\022\r\n\tEPSRS_L"
    "TE\020\010\022\021\n\rEPSRS_GPRSDTM\020\t\022\021\n\rEPSRS_EDGEDTM"
    "\020\n\"_\n\rModemLocation\022\024\n\014country_code\030\001 \001("
    "\r\022\024\n\014network_code\030\002 \001(\r\022\021\n\tarea_code\030\003 \001"
    "(\r\022\017\n\007cell_id\030\004 \001(\r\"\301\t\n\013ModemStatus\022\032\n\022m"
    "odem_manufacturer\030\001 \001(\t\022\023\n\013modem_model\030\002"
    " \001(\t\0228\n\013modem_state\030\003 \001(\0162#.ecu.lapi.pb."
    "ModemStatus.ModemState\022\027\n\017signal_strengt"
    "h\030\004 \001(\001\022\026\n\016signal_quality\030\005 \001(\001\022\017\n\007roami"
    "ng\030\006 \001(\010\022\035\n\025simple_access_bitmask\030\007 \001(\007\022"
    "\035\n\025simple_signal_quality\030\010 \001(\005\022\026\n\016sim_id"
    "entifier\030\t \001(\t\022\020\n\010sim_imsi\030\n \001(\t\022\031\n\021sim_"
    "operator_name\030\013 \001(\t\022\022\n\nsim_active\030\014 \001(\010\022"
    "\033\n\023operator_identifier\030\r \001(\t\022\025\n\roperator"
    "_name\030\016 \001(\t\022\014\n\004imei\030\017 \001(\t\022,\n\010location\030\020 "
    "\001(\0132\032.ecu.lapi.pb.ModemLocation\022\030\n\020netwo"
    "rk_utc_time\030\021 \001(\004\022\024\n\014timestamp_ns\030\022 \001(\004\022"
    "\?\n\014reset_reason\030\023 \001(\0162).ecu.lapi.pb.Mode"
    "mStatus.ModemResetReason\"\314\001\n\nModemState\022"
    "\023\n\006Failed\020\377\377\377\377\377\377\377\377\377\001\022\013\n\007Unknown\020\000\022\010\n\004Ini"
    "t\020\001\022\n\n\006Locked\020\002\022\013\n\007Disable\020\003\022\r\n\tDisablin"
    "g\020\004\022\014\n\010Enabling\020\005\022\013\n\007Enabled\020\006\022\r\n\tSearch"
    "ing\020\007\022\016\n\nRegistered\020\010\022\021\n\rDisconnecting\020\t"
    "\022\016\n\nConnecting\020\n\022\r\n\tConnected\020\013\"\333\001\n\020Acce"
    "ssTechnology\022\021\n\rAccessUnknown\020\000\022\010\n\004POTS\020"
    "\001\022\007\n\003GSM\020\002\022\013\n\007COMPACT\020\004\022\010\n\004GPRS\020\010\022\010\n\004EDG"
    "E\020\020\022\010\n\004UMTS\020 \022\t\n\005HSDPA\020@\022\n\n\005HSUPA\020\200\001\022\t\n\004"
    "HSPA\020\200\002\022\016\n\tHSPA_PLUS\020\200\004\022\n\n\005lXRTT\020\200\010\022\n\n\005E"
    "VDO0\020\200\020\022\n\n\005EVDOA\020\200 \022\n\n\005EVDOB\020\200@\022\t\n\003LTE\020\200"
    "\200\001\022\t\n\003ANY\020\377\377\003\"\337\001\n\020ModemResetReason\022\016\n\nRR"
    "_UNKNOWN\020\000\022\025\n\021RR_SIM_CARD_ERROR\020\001\022\027\n\023RR_"
    "PORT_UNAVAILABLE\020\002\022\023\n\017RR_PORT_TIMEOUT\020\003\022"
    "\027\n\023RR_PORT_WRITE_ERROR\020\004\022\032\n\026RR_INITIALIZ"
    "ATION_FAIL\020\005\022\024\n\020RR_CONTEXT_ERROR\020\006\022\024\n\020RR"
    "_NETWORK_ERROR\020\007\022\025\n\021RR_BE_UNAVAILABLE\020\010\""
    ">\n\010ModemSms\022\016\n\006number\030\001 \001(\t\022\021\n\ttimestamp"
    "\030\002 \001(\t\022\017\n\007content\030\003 \001(\t*O\n\014ModemSimType\022"
    "\023\n\017SIMTYPE_UNKNOWN\020\000\022\024\n\020SIMTYPE_INTERNAL"
    "\020\001\022\024\n\020SIMTYPE_EXTERNAL\020\002", 2624);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "modem.proto", &protobuf_RegisterTypes);
  ModemSim::default_instance_ = new ModemSim();
  ModemSimInformation::default_instance_ = new ModemSimInformation();
  ModemHardware::default_instance_ = new ModemHardware();
  ModemRegistration::default_instance_ = new ModemRegistration();
  ModemLocation::default_instance_ = new ModemLocation();
  ModemStatus::default_instance_ = new ModemStatus();
  ModemSms::default_instance_ = new ModemSms();
  ModemSim::default_instance_->InitAsDefaultInstance();
  ModemSimInformation::default_instance_->InitAsDefaultInstance();
  ModemHardware::default_instance_->InitAsDefaultInstance();
  ModemRegistration::default_instance_->InitAsDefaultInstance();
  ModemLocation::default_instance_->InitAsDefaultInstance();
  ModemStatus::default_instance_->InitAsDefaultInstance();
  ModemSms::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_modem_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_modem_2eproto {
  StaticDescriptorInitializer_modem_2eproto() {
    protobuf_AddDesc_modem_2eproto();
  }
} static_descriptor_initializer_modem_2eproto_;
const ::google::protobuf::EnumDescriptor* ModemSimType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ModemSimType_descriptor_;
}
bool ModemSimType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#ifndef _MSC_VER
const int ModemSim::kTypeFieldNumber;
const int ModemSim::kImsiFieldNumber;
const int ModemSim::kIccidFieldNumber;
#endif  // !_MSC_VER

ModemSim::ModemSim()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ecu.lapi.pb.ModemSim)
}

void ModemSim::InitAsDefaultInstance() {
}

ModemSim::ModemSim(const ModemSim& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ecu.lapi.pb.ModemSim)
}

void ModemSim::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  type_ = 0;
  imsi_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  iccid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ModemSim::~ModemSim() {
  // @@protoc_insertion_point(destructor:ecu.lapi.pb.ModemSim)
  SharedDtor();
}

void ModemSim::SharedDtor() {
  if (imsi_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete imsi_;
  }
  if (iccid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete iccid_;
  }
  if (this != default_instance_) {
  }
}

void ModemSim::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ModemSim::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ModemSim_descriptor_;
}

const ModemSim& ModemSim::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_modem_2eproto();
  return *default_instance_;
}

ModemSim* ModemSim::default_instance_ = NULL;

ModemSim* ModemSim::New() const {
  return new ModemSim;
}

void ModemSim::Clear() {
  if (_has_bits_[0 / 32] & 7) {
    type_ = 0;
    if (has_imsi()) {
      if (imsi_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        imsi_->clear();
      }
    }
    if (has_iccid()) {
      if (iccid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        iccid_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ModemSim::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ecu.lapi.pb.ModemSim)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .ecu.lapi.pb.ModemSimType type = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::ecu::lapi::pb::ModemSimType_IsValid(value)) {
            set_type(static_cast< ::ecu::lapi::pb::ModemSimType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_imsi;
        break;
      }

      // optional string imsi = 2;
      case 2: {
        if (tag == 18) {
         parse_imsi:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_imsi()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->imsi().data(), this->imsi().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "imsi");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_iccid;
        break;
      }

      // optional string iccid = 3;
      case 3: {
        if (tag == 26) {
         parse_iccid:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_iccid()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->iccid().data(), this->iccid().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "iccid");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ecu.lapi.pb.ModemSim)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ecu.lapi.pb.ModemSim)
  return false;
#undef DO_
}

void ModemSim::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ecu.lapi.pb.ModemSim)
  // optional .ecu.lapi.pb.ModemSimType type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // optional string imsi = 2;
  if (has_imsi()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->imsi().data(), this->imsi().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "imsi");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->imsi(), output);
  }

  // optional string iccid = 3;
  if (has_iccid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->iccid().data(), this->iccid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "iccid");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->iccid(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ecu.lapi.pb.ModemSim)
}

::google::protobuf::uint8* ModemSim::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ecu.lapi.pb.ModemSim)
  // optional .ecu.lapi.pb.ModemSimType type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  // optional string imsi = 2;
  if (has_imsi()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->imsi().data(), this->imsi().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "imsi");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->imsi(), target);
  }

  // optional string iccid = 3;
  if (has_iccid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->iccid().data(), this->iccid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "iccid");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->iccid(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ecu.lapi.pb.ModemSim)
  return target;
}

int ModemSim::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .ecu.lapi.pb.ModemSimType type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional string imsi = 2;
    if (has_imsi()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->imsi());
    }

    // optional string iccid = 3;
    if (has_iccid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->iccid());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ModemSim::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ModemSim* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ModemSim*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ModemSim::MergeFrom(const ModemSim& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_imsi()) {
      set_imsi(from.imsi());
    }
    if (from.has_iccid()) {
      set_iccid(from.iccid());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ModemSim::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ModemSim::CopyFrom(const ModemSim& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModemSim::IsInitialized() const {

  return true;
}

void ModemSim::Swap(ModemSim* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(imsi_, other->imsi_);
    std::swap(iccid_, other->iccid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ModemSim::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ModemSim_descriptor_;
  metadata.reflection = ModemSim_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ModemSimInformation::kInternalFieldNumber;
const int ModemSimInformation::kExternalFieldNumber;
const int ModemSimInformation::kActiveFieldNumber;
#endif  // !_MSC_VER

ModemSimInformation::ModemSimInformation()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ecu.lapi.pb.ModemSimInformation)
}

void ModemSimInformation::InitAsDefaultInstance() {
  internal_ = const_cast< ::ecu::lapi::pb::ModemSim*>(&::ecu::lapi::pb::ModemSim::default_instance());
  external_ = const_cast< ::ecu::lapi::pb::ModemSim*>(&::ecu::lapi::pb::ModemSim::default_instance());
}

ModemSimInformation::ModemSimInformation(const ModemSimInformation& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ecu.lapi.pb.ModemSimInformation)
}

void ModemSimInformation::SharedCtor() {
  _cached_size_ = 0;
  internal_ = NULL;
  external_ = NULL;
  active_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ModemSimInformation::~ModemSimInformation() {
  // @@protoc_insertion_point(destructor:ecu.lapi.pb.ModemSimInformation)
  SharedDtor();
}

void ModemSimInformation::SharedDtor() {
  if (this != default_instance_) {
    delete internal_;
    delete external_;
  }
}

void ModemSimInformation::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ModemSimInformation::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ModemSimInformation_descriptor_;
}

const ModemSimInformation& ModemSimInformation::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_modem_2eproto();
  return *default_instance_;
}

ModemSimInformation* ModemSimInformation::default_instance_ = NULL;

ModemSimInformation* ModemSimInformation::New() const {
  return new ModemSimInformation;
}

void ModemSimInformation::Clear() {
  if (_has_bits_[0 / 32] & 7) {
    if (has_internal()) {
      if (internal_ != NULL) internal_->::ecu::lapi::pb::ModemSim::Clear();
    }
    if (has_external()) {
      if (external_ != NULL) external_->::ecu::lapi::pb::ModemSim::Clear();
    }
    active_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ModemSimInformation::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ecu.lapi.pb.ModemSimInformation)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .ecu.lapi.pb.ModemSim internal = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_internal()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_external;
        break;
      }

      // optional .ecu.lapi.pb.ModemSim external = 2;
      case 2: {
        if (tag == 18) {
         parse_external:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_external()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_active;
        break;
      }

      // optional .ecu.lapi.pb.ModemSimType active = 3;
      case 3: {
        if (tag == 24) {
         parse_active:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::ecu::lapi::pb::ModemSimType_IsValid(value)) {
            set_active(static_cast< ::ecu::lapi::pb::ModemSimType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(3, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ecu.lapi.pb.ModemSimInformation)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ecu.lapi.pb.ModemSimInformation)
  return false;
#undef DO_
}

void ModemSimInformation::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ecu.lapi.pb.ModemSimInformation)
  // optional .ecu.lapi.pb.ModemSim internal = 1;
  if (has_internal()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->internal(), output);
  }

  // optional .ecu.lapi.pb.ModemSim external = 2;
  if (has_external()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->external(), output);
  }

  // optional .ecu.lapi.pb.ModemSimType active = 3;
  if (has_active()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->active(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ecu.lapi.pb.ModemSimInformation)
}

::google::protobuf::uint8* ModemSimInformation::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ecu.lapi.pb.ModemSimInformation)
  // optional .ecu.lapi.pb.ModemSim internal = 1;
  if (has_internal()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->internal(), target);
  }

  // optional .ecu.lapi.pb.ModemSim external = 2;
  if (has_external()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->external(), target);
  }

  // optional .ecu.lapi.pb.ModemSimType active = 3;
  if (has_active()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      3, this->active(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ecu.lapi.pb.ModemSimInformation)
  return target;
}

int ModemSimInformation::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .ecu.lapi.pb.ModemSim internal = 1;
    if (has_internal()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->internal());
    }

    // optional .ecu.lapi.pb.ModemSim external = 2;
    if (has_external()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->external());
    }

    // optional .ecu.lapi.pb.ModemSimType active = 3;
    if (has_active()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->active());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ModemSimInformation::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ModemSimInformation* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ModemSimInformation*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ModemSimInformation::MergeFrom(const ModemSimInformation& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_internal()) {
      mutable_internal()->::ecu::lapi::pb::ModemSim::MergeFrom(from.internal());
    }
    if (from.has_external()) {
      mutable_external()->::ecu::lapi::pb::ModemSim::MergeFrom(from.external());
    }
    if (from.has_active()) {
      set_active(from.active());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ModemSimInformation::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ModemSimInformation::CopyFrom(const ModemSimInformation& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModemSimInformation::IsInitialized() const {

  return true;
}

void ModemSimInformation::Swap(ModemSimInformation* other) {
  if (other != this) {
    std::swap(internal_, other->internal_);
    std::swap(external_, other->external_);
    std::swap(active_, other->active_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ModemSimInformation::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ModemSimInformation_descriptor_;
  metadata.reflection = ModemSimInformation_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ModemHardware::kImeiFieldNumber;
const int ModemHardware::kManufacturerFieldNumber;
const int ModemHardware::kModelFieldNumber;
#endif  // !_MSC_VER

ModemHardware::ModemHardware()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ecu.lapi.pb.ModemHardware)
}

void ModemHardware::InitAsDefaultInstance() {
}

ModemHardware::ModemHardware(const ModemHardware& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ecu.lapi.pb.ModemHardware)
}

void ModemHardware::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  imei_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  manufacturer_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  model_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ModemHardware::~ModemHardware() {
  // @@protoc_insertion_point(destructor:ecu.lapi.pb.ModemHardware)
  SharedDtor();
}

void ModemHardware::SharedDtor() {
  if (imei_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete imei_;
  }
  if (manufacturer_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete manufacturer_;
  }
  if (model_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete model_;
  }
  if (this != default_instance_) {
  }
}

void ModemHardware::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ModemHardware::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ModemHardware_descriptor_;
}

const ModemHardware& ModemHardware::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_modem_2eproto();
  return *default_instance_;
}

ModemHardware* ModemHardware::default_instance_ = NULL;

ModemHardware* ModemHardware::New() const {
  return new ModemHardware;
}

void ModemHardware::Clear() {
  if (_has_bits_[0 / 32] & 7) {
    if (has_imei()) {
      if (imei_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        imei_->clear();
      }
    }
    if (has_manufacturer()) {
      if (manufacturer_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        manufacturer_->clear();
      }
    }
    if (has_model()) {
      if (model_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        model_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ModemHardware::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ecu.lapi.pb.ModemHardware)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string imei = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_imei()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->imei().data(), this->imei().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "imei");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_manufacturer;
        break;
      }

      // optional string manufacturer = 2;
      case 2: {
        if (tag == 18) {
         parse_manufacturer:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_manufacturer()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->manufacturer().data(), this->manufacturer().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "manufacturer");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_model;
        break;
      }

      // optional string model = 3;
      case 3: {
        if (tag == 26) {
         parse_model:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_model()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->model().data(), this->model().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "model");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ecu.lapi.pb.ModemHardware)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ecu.lapi.pb.ModemHardware)
  return false;
#undef DO_
}

void ModemHardware::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ecu.lapi.pb.ModemHardware)
  // optional string imei = 1;
  if (has_imei()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->imei().data(), this->imei().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "imei");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->imei(), output);
  }

  // optional string manufacturer = 2;
  if (has_manufacturer()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->manufacturer().data(), this->manufacturer().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "manufacturer");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->manufacturer(), output);
  }

  // optional string model = 3;
  if (has_model()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->model().data(), this->model().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "model");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->model(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ecu.lapi.pb.ModemHardware)
}

::google::protobuf::uint8* ModemHardware::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ecu.lapi.pb.ModemHardware)
  // optional string imei = 1;
  if (has_imei()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->imei().data(), this->imei().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "imei");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->imei(), target);
  }

  // optional string manufacturer = 2;
  if (has_manufacturer()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->manufacturer().data(), this->manufacturer().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "manufacturer");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->manufacturer(), target);
  }

  // optional string model = 3;
  if (has_model()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->model().data(), this->model().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "model");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->model(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ecu.lapi.pb.ModemHardware)
  return target;
}

int ModemHardware::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string imei = 1;
    if (has_imei()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->imei());
    }

    // optional string manufacturer = 2;
    if (has_manufacturer()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->manufacturer());
    }

    // optional string model = 3;
    if (has_model()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->model());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ModemHardware::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ModemHardware* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ModemHardware*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ModemHardware::MergeFrom(const ModemHardware& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_imei()) {
      set_imei(from.imei());
    }
    if (from.has_manufacturer()) {
      set_manufacturer(from.manufacturer());
    }
    if (from.has_model()) {
      set_model(from.model());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ModemHardware::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ModemHardware::CopyFrom(const ModemHardware& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModemHardware::IsInitialized() const {

  return true;
}

void ModemHardware::Swap(ModemHardware* other) {
  if (other != this) {
    std::swap(imei_, other->imei_);
    std::swap(manufacturer_, other->manufacturer_);
    std::swap(model_, other->model_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ModemHardware::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ModemHardware_descriptor_;
  metadata.reflection = ModemHardware_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* ModemRegistration_RegistrationStatus_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ModemRegistration_RegistrationStatus_descriptor_;
}
bool ModemRegistration_RegistrationStatus_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const ModemRegistration_RegistrationStatus ModemRegistration::RS_NOT_SET;
const ModemRegistration_RegistrationStatus ModemRegistration::RS_NOTREG;
const ModemRegistration_RegistrationStatus ModemRegistration::RS_HOME;
const ModemRegistration_RegistrationStatus ModemRegistration::RS_SEARCH;
const ModemRegistration_RegistrationStatus ModemRegistration::RS_DENIED;
const ModemRegistration_RegistrationStatus ModemRegistration::RS_UNKNOWN;
const ModemRegistration_RegistrationStatus ModemRegistration::RS_ROAMING;
const ModemRegistration_RegistrationStatus ModemRegistration::RS_SMSHOME;
const ModemRegistration_RegistrationStatus ModemRegistration::RS_SMSROAM;
const ModemRegistration_RegistrationStatus ModemRegistration::RS_EMERGENCY;
const ModemRegistration_RegistrationStatus ModemRegistration::RS_NCSFBHOME;
const ModemRegistration_RegistrationStatus ModemRegistration::RS_NCSFBROAM;
const ModemRegistration_RegistrationStatus ModemRegistration::RegistrationStatus_MIN;
const ModemRegistration_RegistrationStatus ModemRegistration::RegistrationStatus_MAX;
const int ModemRegistration::RegistrationStatus_ARRAYSIZE;
#endif  // _MSC_VER
const ::google::protobuf::EnumDescriptor* ModemRegistration_RadioAccessTechnology_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ModemRegistration_RadioAccessTechnology_descriptor_;
}
bool ModemRegistration_RadioAccessTechnology_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const ModemRegistration_RadioAccessTechnology ModemRegistration::RAT_NOT_SET;
const ModemRegistration_RadioAccessTechnology ModemRegistration::RAT_GSM;
const ModemRegistration_RadioAccessTechnology ModemRegistration::RAT_GSMC;
const ModemRegistration_RadioAccessTechnology ModemRegistration::RAT_UTRAN;
const ModemRegistration_RadioAccessTechnology ModemRegistration::RAT_GSMEDGE;
const ModemRegistration_RadioAccessTechnology ModemRegistration::RAT_UTRAND;
const ModemRegistration_RadioAccessTechnology ModemRegistration::RAT_UTRANU;
const ModemRegistration_RadioAccessTechnology ModemRegistration::RAT_UTRANDU;
const ModemRegistration_RadioAccessTechnology ModemRegistration::RAT_EUTRAN;
const ModemRegistration_RadioAccessTechnology ModemRegistration::RAT_INVALID;
const ModemRegistration_RadioAccessTechnology ModemRegistration::RadioAccessTechnology_MIN;
const ModemRegistration_RadioAccessTechnology ModemRegistration::RadioAccessTechnology_MAX;
const int ModemRegistration::RadioAccessTechnology_ARRAYSIZE;
#endif  // _MSC_VER
const ::google::protobuf::EnumDescriptor* ModemRegistration_ExtPSRegStatus_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ModemRegistration_ExtPSRegStatus_descriptor_;
}
bool ModemRegistration_ExtPSRegStatus_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const ModemRegistration_ExtPSRegStatus ModemRegistration::EPSRS_NOT_SET;
const ModemRegistration_ExtPSRegStatus ModemRegistration::EPSRS_NONE;
const ModemRegistration_ExtPSRegStatus ModemRegistration::EPSRS_GPRS;
const ModemRegistration_ExtPSRegStatus ModemRegistration::EPSRS_EDGE;
const ModemRegistration_ExtPSRegStatus ModemRegistration::EPSRS_WCDMA;
const ModemRegistration_ExtPSRegStatus ModemRegistration::EPSRS_HSDPA;
const ModemRegistration_ExtPSRegStatus ModemRegistration::EPSRS_HSUPA;
const ModemRegistration_ExtPSRegStatus ModemRegistration::EPSRS_HSDUPA;
const ModemRegistration_ExtPSRegStatus ModemRegistration::EPSRS_LTE;
const ModemRegistration_ExtPSRegStatus ModemRegistration::EPSRS_GPRSDTM;
const ModemRegistration_ExtPSRegStatus ModemRegistration::EPSRS_EDGEDTM;
const ModemRegistration_ExtPSRegStatus ModemRegistration::ExtPSRegStatus_MIN;
const ModemRegistration_ExtPSRegStatus ModemRegistration::ExtPSRegStatus_MAX;
const int ModemRegistration::ExtPSRegStatus_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int ModemRegistration::kRatFieldNumber;
const int ModemRegistration::kRegStatusFieldNumber;
const int ModemRegistration::kPsRegStatusFieldNumber;
#endif  // !_MSC_VER

ModemRegistration::ModemRegistration()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ecu.lapi.pb.ModemRegistration)
}

void ModemRegistration::InitAsDefaultInstance() {
}

ModemRegistration::ModemRegistration(const ModemRegistration& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ecu.lapi.pb.ModemRegistration)
}

void ModemRegistration::SharedCtor() {
  _cached_size_ = 0;
  rat_ = 0;
  reg_status_ = 0;
  ps_reg_status_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ModemRegistration::~ModemRegistration() {
  // @@protoc_insertion_point(destructor:ecu.lapi.pb.ModemRegistration)
  SharedDtor();
}

void ModemRegistration::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ModemRegistration::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ModemRegistration::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ModemRegistration_descriptor_;
}

const ModemRegistration& ModemRegistration::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_modem_2eproto();
  return *default_instance_;
}

ModemRegistration* ModemRegistration::default_instance_ = NULL;

ModemRegistration* ModemRegistration::New() const {
  return new ModemRegistration;
}

void ModemRegistration::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<ModemRegistration*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(rat_, ps_reg_status_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ModemRegistration::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ecu.lapi.pb.ModemRegistration)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .ecu.lapi.pb.ModemRegistration.RadioAccessTechnology rat = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::ecu::lapi::pb::ModemRegistration_RadioAccessTechnology_IsValid(value)) {
            set_rat(static_cast< ::ecu::lapi::pb::ModemRegistration_RadioAccessTechnology >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_reg_status;
        break;
      }

      // optional .ecu.lapi.pb.ModemRegistration.RegistrationStatus reg_status = 2;
      case 2: {
        if (tag == 16) {
         parse_reg_status:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::ecu::lapi::pb::ModemRegistration_RegistrationStatus_IsValid(value)) {
            set_reg_status(static_cast< ::ecu::lapi::pb::ModemRegistration_RegistrationStatus >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_ps_reg_status;
        break;
      }

      // optional .ecu.lapi.pb.ModemRegistration.ExtPSRegStatus ps_reg_status = 3;
      case 3: {
        if (tag == 24) {
         parse_ps_reg_status:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::ecu::lapi::pb::ModemRegistration_ExtPSRegStatus_IsValid(value)) {
            set_ps_reg_status(static_cast< ::ecu::lapi::pb::ModemRegistration_ExtPSRegStatus >(value));
          } else {
            mutable_unknown_fields()->AddVarint(3, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ecu.lapi.pb.ModemRegistration)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ecu.lapi.pb.ModemRegistration)
  return false;
#undef DO_
}

void ModemRegistration::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ecu.lapi.pb.ModemRegistration)
  // optional .ecu.lapi.pb.ModemRegistration.RadioAccessTechnology rat = 1;
  if (has_rat()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->rat(), output);
  }

  // optional .ecu.lapi.pb.ModemRegistration.RegistrationStatus reg_status = 2;
  if (has_reg_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->reg_status(), output);
  }

  // optional .ecu.lapi.pb.ModemRegistration.ExtPSRegStatus ps_reg_status = 3;
  if (has_ps_reg_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->ps_reg_status(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ecu.lapi.pb.ModemRegistration)
}

::google::protobuf::uint8* ModemRegistration::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ecu.lapi.pb.ModemRegistration)
  // optional .ecu.lapi.pb.ModemRegistration.RadioAccessTechnology rat = 1;
  if (has_rat()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->rat(), target);
  }

  // optional .ecu.lapi.pb.ModemRegistration.RegistrationStatus reg_status = 2;
  if (has_reg_status()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->reg_status(), target);
  }

  // optional .ecu.lapi.pb.ModemRegistration.ExtPSRegStatus ps_reg_status = 3;
  if (has_ps_reg_status()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      3, this->ps_reg_status(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ecu.lapi.pb.ModemRegistration)
  return target;
}

int ModemRegistration::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .ecu.lapi.pb.ModemRegistration.RadioAccessTechnology rat = 1;
    if (has_rat()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->rat());
    }

    // optional .ecu.lapi.pb.ModemRegistration.RegistrationStatus reg_status = 2;
    if (has_reg_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->reg_status());
    }

    // optional .ecu.lapi.pb.ModemRegistration.ExtPSRegStatus ps_reg_status = 3;
    if (has_ps_reg_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->ps_reg_status());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ModemRegistration::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ModemRegistration* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ModemRegistration*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ModemRegistration::MergeFrom(const ModemRegistration& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_rat()) {
      set_rat(from.rat());
    }
    if (from.has_reg_status()) {
      set_reg_status(from.reg_status());
    }
    if (from.has_ps_reg_status()) {
      set_ps_reg_status(from.ps_reg_status());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ModemRegistration::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ModemRegistration::CopyFrom(const ModemRegistration& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModemRegistration::IsInitialized() const {

  return true;
}

void ModemRegistration::Swap(ModemRegistration* other) {
  if (other != this) {
    std::swap(rat_, other->rat_);
    std::swap(reg_status_, other->reg_status_);
    std::swap(ps_reg_status_, other->ps_reg_status_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ModemRegistration::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ModemRegistration_descriptor_;
  metadata.reflection = ModemRegistration_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ModemLocation::kCountryCodeFieldNumber;
const int ModemLocation::kNetworkCodeFieldNumber;
const int ModemLocation::kAreaCodeFieldNumber;
const int ModemLocation::kCellIdFieldNumber;
#endif  // !_MSC_VER

ModemLocation::ModemLocation()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ecu.lapi.pb.ModemLocation)
}

void ModemLocation::InitAsDefaultInstance() {
}

ModemLocation::ModemLocation(const ModemLocation& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ecu.lapi.pb.ModemLocation)
}

void ModemLocation::SharedCtor() {
  _cached_size_ = 0;
  country_code_ = 0u;
  network_code_ = 0u;
  area_code_ = 0u;
  cell_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ModemLocation::~ModemLocation() {
  // @@protoc_insertion_point(destructor:ecu.lapi.pb.ModemLocation)
  SharedDtor();
}

void ModemLocation::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ModemLocation::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ModemLocation::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ModemLocation_descriptor_;
}

const ModemLocation& ModemLocation::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_modem_2eproto();
  return *default_instance_;
}

ModemLocation* ModemLocation::default_instance_ = NULL;

ModemLocation* ModemLocation::New() const {
  return new ModemLocation;
}

void ModemLocation::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<ModemLocation*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(country_code_, cell_id_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ModemLocation::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ecu.lapi.pb.ModemLocation)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 country_code = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &country_code_)));
          set_has_country_code();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_network_code;
        break;
      }

      // optional uint32 network_code = 2;
      case 2: {
        if (tag == 16) {
         parse_network_code:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &network_code_)));
          set_has_network_code();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_area_code;
        break;
      }

      // optional uint32 area_code = 3;
      case 3: {
        if (tag == 24) {
         parse_area_code:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &area_code_)));
          set_has_area_code();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_cell_id;
        break;
      }

      // optional uint32 cell_id = 4;
      case 4: {
        if (tag == 32) {
         parse_cell_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &cell_id_)));
          set_has_cell_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ecu.lapi.pb.ModemLocation)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ecu.lapi.pb.ModemLocation)
  return false;
#undef DO_
}

void ModemLocation::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ecu.lapi.pb.ModemLocation)
  // optional uint32 country_code = 1;
  if (has_country_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->country_code(), output);
  }

  // optional uint32 network_code = 2;
  if (has_network_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->network_code(), output);
  }

  // optional uint32 area_code = 3;
  if (has_area_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->area_code(), output);
  }

  // optional uint32 cell_id = 4;
  if (has_cell_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->cell_id(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ecu.lapi.pb.ModemLocation)
}

::google::protobuf::uint8* ModemLocation::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ecu.lapi.pb.ModemLocation)
  // optional uint32 country_code = 1;
  if (has_country_code()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->country_code(), target);
  }

  // optional uint32 network_code = 2;
  if (has_network_code()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->network_code(), target);
  }

  // optional uint32 area_code = 3;
  if (has_area_code()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->area_code(), target);
  }

  // optional uint32 cell_id = 4;
  if (has_cell_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->cell_id(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ecu.lapi.pb.ModemLocation)
  return target;
}

int ModemLocation::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 country_code = 1;
    if (has_country_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->country_code());
    }

    // optional uint32 network_code = 2;
    if (has_network_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->network_code());
    }

    // optional uint32 area_code = 3;
    if (has_area_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->area_code());
    }

    // optional uint32 cell_id = 4;
    if (has_cell_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->cell_id());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ModemLocation::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ModemLocation* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ModemLocation*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ModemLocation::MergeFrom(const ModemLocation& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_country_code()) {
      set_country_code(from.country_code());
    }
    if (from.has_network_code()) {
      set_network_code(from.network_code());
    }
    if (from.has_area_code()) {
      set_area_code(from.area_code());
    }
    if (from.has_cell_id()) {
      set_cell_id(from.cell_id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ModemLocation::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ModemLocation::CopyFrom(const ModemLocation& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModemLocation::IsInitialized() const {

  return true;
}

void ModemLocation::Swap(ModemLocation* other) {
  if (other != this) {
    std::swap(country_code_, other->country_code_);
    std::swap(network_code_, other->network_code_);
    std::swap(area_code_, other->area_code_);
    std::swap(cell_id_, other->cell_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ModemLocation::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ModemLocation_descriptor_;
  metadata.reflection = ModemLocation_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* ModemStatus_ModemState_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ModemStatus_ModemState_descriptor_;
}
bool ModemStatus_ModemState_IsValid(int value) {
  switch(value) {
    case -1:
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const ModemStatus_ModemState ModemStatus::Failed;
const ModemStatus_ModemState ModemStatus::Unknown;
const ModemStatus_ModemState ModemStatus::Init;
const ModemStatus_ModemState ModemStatus::Locked;
const ModemStatus_ModemState ModemStatus::Disable;
const ModemStatus_ModemState ModemStatus::Disabling;
const ModemStatus_ModemState ModemStatus::Enabling;
const ModemStatus_ModemState ModemStatus::Enabled;
const ModemStatus_ModemState ModemStatus::Searching;
const ModemStatus_ModemState ModemStatus::Registered;
const ModemStatus_ModemState ModemStatus::Disconnecting;
const ModemStatus_ModemState ModemStatus::Connecting;
const ModemStatus_ModemState ModemStatus::Connected;
const ModemStatus_ModemState ModemStatus::ModemState_MIN;
const ModemStatus_ModemState ModemStatus::ModemState_MAX;
const int ModemStatus::ModemState_ARRAYSIZE;
#endif  // _MSC_VER
const ::google::protobuf::EnumDescriptor* ModemStatus_AccessTechnology_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ModemStatus_AccessTechnology_descriptor_;
}
bool ModemStatus_AccessTechnology_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 4:
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 65535:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const ModemStatus_AccessTechnology ModemStatus::AccessUnknown;
const ModemStatus_AccessTechnology ModemStatus::POTS;
const ModemStatus_AccessTechnology ModemStatus::GSM;
const ModemStatus_AccessTechnology ModemStatus::COMPACT;
const ModemStatus_AccessTechnology ModemStatus::GPRS;
const ModemStatus_AccessTechnology ModemStatus::EDGE;
const ModemStatus_AccessTechnology ModemStatus::UMTS;
const ModemStatus_AccessTechnology ModemStatus::HSDPA;
const ModemStatus_AccessTechnology ModemStatus::HSUPA;
const ModemStatus_AccessTechnology ModemStatus::HSPA;
const ModemStatus_AccessTechnology ModemStatus::HSPA_PLUS;
const ModemStatus_AccessTechnology ModemStatus::lXRTT;
const ModemStatus_AccessTechnology ModemStatus::EVDO0;
const ModemStatus_AccessTechnology ModemStatus::EVDOA;
const ModemStatus_AccessTechnology ModemStatus::EVDOB;
const ModemStatus_AccessTechnology ModemStatus::LTE;
const ModemStatus_AccessTechnology ModemStatus::ANY;
const ModemStatus_AccessTechnology ModemStatus::AccessTechnology_MIN;
const ModemStatus_AccessTechnology ModemStatus::AccessTechnology_MAX;
const int ModemStatus::AccessTechnology_ARRAYSIZE;
#endif  // _MSC_VER
const ::google::protobuf::EnumDescriptor* ModemStatus_ModemResetReason_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ModemStatus_ModemResetReason_descriptor_;
}
bool ModemStatus_ModemResetReason_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const ModemStatus_ModemResetReason ModemStatus::RR_UNKNOWN;
const ModemStatus_ModemResetReason ModemStatus::RR_SIM_CARD_ERROR;
const ModemStatus_ModemResetReason ModemStatus::RR_PORT_UNAVAILABLE;
const ModemStatus_ModemResetReason ModemStatus::RR_PORT_TIMEOUT;
const ModemStatus_ModemResetReason ModemStatus::RR_PORT_WRITE_ERROR;
const ModemStatus_ModemResetReason ModemStatus::RR_INITIALIZATION_FAIL;
const ModemStatus_ModemResetReason ModemStatus::RR_CONTEXT_ERROR;
const ModemStatus_ModemResetReason ModemStatus::RR_NETWORK_ERROR;
const ModemStatus_ModemResetReason ModemStatus::RR_BE_UNAVAILABLE;
const ModemStatus_ModemResetReason ModemStatus::ModemResetReason_MIN;
const ModemStatus_ModemResetReason ModemStatus::ModemResetReason_MAX;
const int ModemStatus::ModemResetReason_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int ModemStatus::kModemManufacturerFieldNumber;
const int ModemStatus::kModemModelFieldNumber;
const int ModemStatus::kModemStateFieldNumber;
const int ModemStatus::kSignalStrengthFieldNumber;
const int ModemStatus::kSignalQualityFieldNumber;
const int ModemStatus::kRoamingFieldNumber;
const int ModemStatus::kSimpleAccessBitmaskFieldNumber;
const int ModemStatus::kSimpleSignalQualityFieldNumber;
const int ModemStatus::kSimIdentifierFieldNumber;
const int ModemStatus::kSimImsiFieldNumber;
const int ModemStatus::kSimOperatorNameFieldNumber;
const int ModemStatus::kSimActiveFieldNumber;
const int ModemStatus::kOperatorIdentifierFieldNumber;
const int ModemStatus::kOperatorNameFieldNumber;
const int ModemStatus::kImeiFieldNumber;
const int ModemStatus::kLocationFieldNumber;
const int ModemStatus::kNetworkUtcTimeFieldNumber;
const int ModemStatus::kTimestampNsFieldNumber;
const int ModemStatus::kResetReasonFieldNumber;
#endif  // !_MSC_VER

ModemStatus::ModemStatus()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ecu.lapi.pb.ModemStatus)
}

void ModemStatus::InitAsDefaultInstance() {
  location_ = const_cast< ::ecu::lapi::pb::ModemLocation*>(&::ecu::lapi::pb::ModemLocation::default_instance());
}

ModemStatus::ModemStatus(const ModemStatus& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ecu.lapi.pb.ModemStatus)
}

void ModemStatus::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  modem_manufacturer_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  modem_model_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  modem_state_ = -1;
  signal_strength_ = 0;
  signal_quality_ = 0;
  roaming_ = false;
  simple_access_bitmask_ = 0u;
  simple_signal_quality_ = 0;
  sim_identifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  sim_imsi_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  sim_operator_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  sim_active_ = false;
  operator_identifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  operator_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  imei_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  location_ = NULL;
  network_utc_time_ = GOOGLE_ULONGLONG(0);
  timestamp_ns_ = GOOGLE_ULONGLONG(0);
  reset_reason_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ModemStatus::~ModemStatus() {
  // @@protoc_insertion_point(destructor:ecu.lapi.pb.ModemStatus)
  SharedDtor();
}

void ModemStatus::SharedDtor() {
  if (modem_manufacturer_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete modem_manufacturer_;
  }
  if (modem_model_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete modem_model_;
  }
  if (sim_identifier_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete sim_identifier_;
  }
  if (sim_imsi_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete sim_imsi_;
  }
  if (sim_operator_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete sim_operator_name_;
  }
  if (operator_identifier_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete operator_identifier_;
  }
  if (operator_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete operator_name_;
  }
  if (imei_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete imei_;
  }
  if (this != default_instance_) {
    delete location_;
  }
}

void ModemStatus::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ModemStatus::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ModemStatus_descriptor_;
}

const ModemStatus& ModemStatus::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_modem_2eproto();
  return *default_instance_;
}

ModemStatus* ModemStatus::default_instance_ = NULL;

ModemStatus* ModemStatus::New() const {
  return new ModemStatus;
}

void ModemStatus::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<ModemStatus*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 255) {
    ZR_(signal_strength_, signal_quality_);
    ZR_(simple_access_bitmask_, roaming_);
    if (has_modem_manufacturer()) {
      if (modem_manufacturer_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        modem_manufacturer_->clear();
      }
    }
    if (has_modem_model()) {
      if (modem_model_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        modem_model_->clear();
      }
    }
    modem_state_ = -1;
  }
  if (_has_bits_[8 / 32] & 65280) {
    if (has_sim_identifier()) {
      if (sim_identifier_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        sim_identifier_->clear();
      }
    }
    if (has_sim_imsi()) {
      if (sim_imsi_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        sim_imsi_->clear();
      }
    }
    if (has_sim_operator_name()) {
      if (sim_operator_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        sim_operator_name_->clear();
      }
    }
    sim_active_ = false;
    if (has_operator_identifier()) {
      if (operator_identifier_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        operator_identifier_->clear();
      }
    }
    if (has_operator_name()) {
      if (operator_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        operator_name_->clear();
      }
    }
    if (has_imei()) {
      if (imei_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        imei_->clear();
      }
    }
    if (has_location()) {
      if (location_ != NULL) location_->::ecu::lapi::pb::ModemLocation::Clear();
    }
  }
  ZR_(network_utc_time_, reset_reason_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ModemStatus::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ecu.lapi.pb.ModemStatus)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string modem_manufacturer = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_modem_manufacturer()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->modem_manufacturer().data(), this->modem_manufacturer().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "modem_manufacturer");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_modem_model;
        break;
      }

      // optional string modem_model = 2;
      case 2: {
        if (tag == 18) {
         parse_modem_model:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_modem_model()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->modem_model().data(), this->modem_model().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "modem_model");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_modem_state;
        break;
      }

      // optional .ecu.lapi.pb.ModemStatus.ModemState modem_state = 3;
      case 3: {
        if (tag == 24) {
         parse_modem_state:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::ecu::lapi::pb::ModemStatus_ModemState_IsValid(value)) {
            set_modem_state(static_cast< ::ecu::lapi::pb::ModemStatus_ModemState >(value));
          } else {
            mutable_unknown_fields()->AddVarint(3, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(33)) goto parse_signal_strength;
        break;
      }

      // optional double signal_strength = 4;
      case 4: {
        if (tag == 33) {
         parse_signal_strength:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &signal_strength_)));
          set_has_signal_strength();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(41)) goto parse_signal_quality;
        break;
      }

      // optional double signal_quality = 5;
      case 5: {
        if (tag == 41) {
         parse_signal_quality:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &signal_quality_)));
          set_has_signal_quality();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_roaming;
        break;
      }

      // optional bool roaming = 6;
      case 6: {
        if (tag == 48) {
         parse_roaming:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &roaming_)));
          set_has_roaming();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(61)) goto parse_simple_access_bitmask;
        break;
      }

      // optional fixed32 simple_access_bitmask = 7;
      case 7: {
        if (tag == 61) {
         parse_simple_access_bitmask:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED32>(
                 input, &simple_access_bitmask_)));
          set_has_simple_access_bitmask();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_simple_signal_quality;
        break;
      }

      // optional int32 simple_signal_quality = 8;
      case 8: {
        if (tag == 64) {
         parse_simple_signal_quality:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &simple_signal_quality_)));
          set_has_simple_signal_quality();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(74)) goto parse_sim_identifier;
        break;
      }

      // optional string sim_identifier = 9;
      case 9: {
        if (tag == 74) {
         parse_sim_identifier:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_sim_identifier()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->sim_identifier().data(), this->sim_identifier().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "sim_identifier");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(82)) goto parse_sim_imsi;
        break;
      }

      // optional string sim_imsi = 10;
      case 10: {
        if (tag == 82) {
         parse_sim_imsi:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_sim_imsi()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->sim_imsi().data(), this->sim_imsi().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "sim_imsi");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(90)) goto parse_sim_operator_name;
        break;
      }

      // optional string sim_operator_name = 11;
      case 11: {
        if (tag == 90) {
         parse_sim_operator_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_sim_operator_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->sim_operator_name().data(), this->sim_operator_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "sim_operator_name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(96)) goto parse_sim_active;
        break;
      }

      // optional bool sim_active = 12;
      case 12: {
        if (tag == 96) {
         parse_sim_active:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &sim_active_)));
          set_has_sim_active();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(106)) goto parse_operator_identifier;
        break;
      }

      // optional string operator_identifier = 13;
      case 13: {
        if (tag == 106) {
         parse_operator_identifier:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_operator_identifier()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->operator_identifier().data(), this->operator_identifier().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "operator_identifier");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(114)) goto parse_operator_name;
        break;
      }

      // optional string operator_name = 14;
      case 14: {
        if (tag == 114) {
         parse_operator_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_operator_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->operator_name().data(), this->operator_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "operator_name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(122)) goto parse_imei;
        break;
      }

      // optional string imei = 15;
      case 15: {
        if (tag == 122) {
         parse_imei:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_imei()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->imei().data(), this->imei().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "imei");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(130)) goto parse_location;
        break;
      }

      // optional .ecu.lapi.pb.ModemLocation location = 16;
      case 16: {
        if (tag == 130) {
         parse_location:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_location()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(136)) goto parse_network_utc_time;
        break;
      }

      // optional uint64 network_utc_time = 17;
      case 17: {
        if (tag == 136) {
         parse_network_utc_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &network_utc_time_)));
          set_has_network_utc_time();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(144)) goto parse_timestamp_ns;
        break;
      }

      // optional uint64 timestamp_ns = 18;
      case 18: {
        if (tag == 144) {
         parse_timestamp_ns:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &timestamp_ns_)));
          set_has_timestamp_ns();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(152)) goto parse_reset_reason;
        break;
      }

      // optional .ecu.lapi.pb.ModemStatus.ModemResetReason reset_reason = 19;
      case 19: {
        if (tag == 152) {
         parse_reset_reason:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::ecu::lapi::pb::ModemStatus_ModemResetReason_IsValid(value)) {
            set_reset_reason(static_cast< ::ecu::lapi::pb::ModemStatus_ModemResetReason >(value));
          } else {
            mutable_unknown_fields()->AddVarint(19, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ecu.lapi.pb.ModemStatus)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ecu.lapi.pb.ModemStatus)
  return false;
#undef DO_
}

void ModemStatus::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ecu.lapi.pb.ModemStatus)
  // optional string modem_manufacturer = 1;
  if (has_modem_manufacturer()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->modem_manufacturer().data(), this->modem_manufacturer().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "modem_manufacturer");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->modem_manufacturer(), output);
  }

  // optional string modem_model = 2;
  if (has_modem_model()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->modem_model().data(), this->modem_model().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "modem_model");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->modem_model(), output);
  }

  // optional .ecu.lapi.pb.ModemStatus.ModemState modem_state = 3;
  if (has_modem_state()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->modem_state(), output);
  }

  // optional double signal_strength = 4;
  if (has_signal_strength()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(4, this->signal_strength(), output);
  }

  // optional double signal_quality = 5;
  if (has_signal_quality()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(5, this->signal_quality(), output);
  }

  // optional bool roaming = 6;
  if (has_roaming()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(6, this->roaming(), output);
  }

  // optional fixed32 simple_access_bitmask = 7;
  if (has_simple_access_bitmask()) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed32(7, this->simple_access_bitmask(), output);
  }

  // optional int32 simple_signal_quality = 8;
  if (has_simple_signal_quality()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(8, this->simple_signal_quality(), output);
  }

  // optional string sim_identifier = 9;
  if (has_sim_identifier()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->sim_identifier().data(), this->sim_identifier().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "sim_identifier");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      9, this->sim_identifier(), output);
  }

  // optional string sim_imsi = 10;
  if (has_sim_imsi()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->sim_imsi().data(), this->sim_imsi().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "sim_imsi");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      10, this->sim_imsi(), output);
  }

  // optional string sim_operator_name = 11;
  if (has_sim_operator_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->sim_operator_name().data(), this->sim_operator_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "sim_operator_name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      11, this->sim_operator_name(), output);
  }

  // optional bool sim_active = 12;
  if (has_sim_active()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(12, this->sim_active(), output);
  }

  // optional string operator_identifier = 13;
  if (has_operator_identifier()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->operator_identifier().data(), this->operator_identifier().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "operator_identifier");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      13, this->operator_identifier(), output);
  }

  // optional string operator_name = 14;
  if (has_operator_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->operator_name().data(), this->operator_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "operator_name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      14, this->operator_name(), output);
  }

  // optional string imei = 15;
  if (has_imei()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->imei().data(), this->imei().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "imei");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      15, this->imei(), output);
  }

  // optional .ecu.lapi.pb.ModemLocation location = 16;
  if (has_location()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      16, this->location(), output);
  }

  // optional uint64 network_utc_time = 17;
  if (has_network_utc_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(17, this->network_utc_time(), output);
  }

  // optional uint64 timestamp_ns = 18;
  if (has_timestamp_ns()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(18, this->timestamp_ns(), output);
  }

  // optional .ecu.lapi.pb.ModemStatus.ModemResetReason reset_reason = 19;
  if (has_reset_reason()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      19, this->reset_reason(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ecu.lapi.pb.ModemStatus)
}

::google::protobuf::uint8* ModemStatus::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ecu.lapi.pb.ModemStatus)
  // optional string modem_manufacturer = 1;
  if (has_modem_manufacturer()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->modem_manufacturer().data(), this->modem_manufacturer().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "modem_manufacturer");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->modem_manufacturer(), target);
  }

  // optional string modem_model = 2;
  if (has_modem_model()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->modem_model().data(), this->modem_model().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "modem_model");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->modem_model(), target);
  }

  // optional .ecu.lapi.pb.ModemStatus.ModemState modem_state = 3;
  if (has_modem_state()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      3, this->modem_state(), target);
  }

  // optional double signal_strength = 4;
  if (has_signal_strength()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(4, this->signal_strength(), target);
  }

  // optional double signal_quality = 5;
  if (has_signal_quality()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(5, this->signal_quality(), target);
  }

  // optional bool roaming = 6;
  if (has_roaming()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(6, this->roaming(), target);
  }

  // optional fixed32 simple_access_bitmask = 7;
  if (has_simple_access_bitmask()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFixed32ToArray(7, this->simple_access_bitmask(), target);
  }

  // optional int32 simple_signal_quality = 8;
  if (has_simple_signal_quality()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(8, this->simple_signal_quality(), target);
  }

  // optional string sim_identifier = 9;
  if (has_sim_identifier()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->sim_identifier().data(), this->sim_identifier().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "sim_identifier");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        9, this->sim_identifier(), target);
  }

  // optional string sim_imsi = 10;
  if (has_sim_imsi()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->sim_imsi().data(), this->sim_imsi().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "sim_imsi");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        10, this->sim_imsi(), target);
  }

  // optional string sim_operator_name = 11;
  if (has_sim_operator_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->sim_operator_name().data(), this->sim_operator_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "sim_operator_name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        11, this->sim_operator_name(), target);
  }

  // optional bool sim_active = 12;
  if (has_sim_active()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(12, this->sim_active(), target);
  }

  // optional string operator_identifier = 13;
  if (has_operator_identifier()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->operator_identifier().data(), this->operator_identifier().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "operator_identifier");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        13, this->operator_identifier(), target);
  }

  // optional string operator_name = 14;
  if (has_operator_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->operator_name().data(), this->operator_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "operator_name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        14, this->operator_name(), target);
  }

  // optional string imei = 15;
  if (has_imei()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->imei().data(), this->imei().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "imei");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        15, this->imei(), target);
  }

  // optional .ecu.lapi.pb.ModemLocation location = 16;
  if (has_location()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        16, this->location(), target);
  }

  // optional uint64 network_utc_time = 17;
  if (has_network_utc_time()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(17, this->network_utc_time(), target);
  }

  // optional uint64 timestamp_ns = 18;
  if (has_timestamp_ns()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(18, this->timestamp_ns(), target);
  }

  // optional .ecu.lapi.pb.ModemStatus.ModemResetReason reset_reason = 19;
  if (has_reset_reason()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      19, this->reset_reason(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ecu.lapi.pb.ModemStatus)
  return target;
}

int ModemStatus::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string modem_manufacturer = 1;
    if (has_modem_manufacturer()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->modem_manufacturer());
    }

    // optional string modem_model = 2;
    if (has_modem_model()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->modem_model());
    }

    // optional .ecu.lapi.pb.ModemStatus.ModemState modem_state = 3;
    if (has_modem_state()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->modem_state());
    }

    // optional double signal_strength = 4;
    if (has_signal_strength()) {
      total_size += 1 + 8;
    }

    // optional double signal_quality = 5;
    if (has_signal_quality()) {
      total_size += 1 + 8;
    }

    // optional bool roaming = 6;
    if (has_roaming()) {
      total_size += 1 + 1;
    }

    // optional fixed32 simple_access_bitmask = 7;
    if (has_simple_access_bitmask()) {
      total_size += 1 + 4;
    }

    // optional int32 simple_signal_quality = 8;
    if (has_simple_signal_quality()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->simple_signal_quality());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional string sim_identifier = 9;
    if (has_sim_identifier()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->sim_identifier());
    }

    // optional string sim_imsi = 10;
    if (has_sim_imsi()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->sim_imsi());
    }

    // optional string sim_operator_name = 11;
    if (has_sim_operator_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->sim_operator_name());
    }

    // optional bool sim_active = 12;
    if (has_sim_active()) {
      total_size += 1 + 1;
    }

    // optional string operator_identifier = 13;
    if (has_operator_identifier()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->operator_identifier());
    }

    // optional string operator_name = 14;
    if (has_operator_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->operator_name());
    }

    // optional string imei = 15;
    if (has_imei()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->imei());
    }

    // optional .ecu.lapi.pb.ModemLocation location = 16;
    if (has_location()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->location());
    }

  }
  if (_has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    // optional uint64 network_utc_time = 17;
    if (has_network_utc_time()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->network_utc_time());
    }

    // optional uint64 timestamp_ns = 18;
    if (has_timestamp_ns()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->timestamp_ns());
    }

    // optional .ecu.lapi.pb.ModemStatus.ModemResetReason reset_reason = 19;
    if (has_reset_reason()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->reset_reason());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ModemStatus::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ModemStatus* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ModemStatus*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ModemStatus::MergeFrom(const ModemStatus& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_modem_manufacturer()) {
      set_modem_manufacturer(from.modem_manufacturer());
    }
    if (from.has_modem_model()) {
      set_modem_model(from.modem_model());
    }
    if (from.has_modem_state()) {
      set_modem_state(from.modem_state());
    }
    if (from.has_signal_strength()) {
      set_signal_strength(from.signal_strength());
    }
    if (from.has_signal_quality()) {
      set_signal_quality(from.signal_quality());
    }
    if (from.has_roaming()) {
      set_roaming(from.roaming());
    }
    if (from.has_simple_access_bitmask()) {
      set_simple_access_bitmask(from.simple_access_bitmask());
    }
    if (from.has_simple_signal_quality()) {
      set_simple_signal_quality(from.simple_signal_quality());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_sim_identifier()) {
      set_sim_identifier(from.sim_identifier());
    }
    if (from.has_sim_imsi()) {
      set_sim_imsi(from.sim_imsi());
    }
    if (from.has_sim_operator_name()) {
      set_sim_operator_name(from.sim_operator_name());
    }
    if (from.has_sim_active()) {
      set_sim_active(from.sim_active());
    }
    if (from.has_operator_identifier()) {
      set_operator_identifier(from.operator_identifier());
    }
    if (from.has_operator_name()) {
      set_operator_name(from.operator_name());
    }
    if (from.has_imei()) {
      set_imei(from.imei());
    }
    if (from.has_location()) {
      mutable_location()->::ecu::lapi::pb::ModemLocation::MergeFrom(from.location());
    }
  }
  if (from._has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    if (from.has_network_utc_time()) {
      set_network_utc_time(from.network_utc_time());
    }
    if (from.has_timestamp_ns()) {
      set_timestamp_ns(from.timestamp_ns());
    }
    if (from.has_reset_reason()) {
      set_reset_reason(from.reset_reason());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ModemStatus::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ModemStatus::CopyFrom(const ModemStatus& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModemStatus::IsInitialized() const {

  return true;
}

void ModemStatus::Swap(ModemStatus* other) {
  if (other != this) {
    std::swap(modem_manufacturer_, other->modem_manufacturer_);
    std::swap(modem_model_, other->modem_model_);
    std::swap(modem_state_, other->modem_state_);
    std::swap(signal_strength_, other->signal_strength_);
    std::swap(signal_quality_, other->signal_quality_);
    std::swap(roaming_, other->roaming_);
    std::swap(simple_access_bitmask_, other->simple_access_bitmask_);
    std::swap(simple_signal_quality_, other->simple_signal_quality_);
    std::swap(sim_identifier_, other->sim_identifier_);
    std::swap(sim_imsi_, other->sim_imsi_);
    std::swap(sim_operator_name_, other->sim_operator_name_);
    std::swap(sim_active_, other->sim_active_);
    std::swap(operator_identifier_, other->operator_identifier_);
    std::swap(operator_name_, other->operator_name_);
    std::swap(imei_, other->imei_);
    std::swap(location_, other->location_);
    std::swap(network_utc_time_, other->network_utc_time_);
    std::swap(timestamp_ns_, other->timestamp_ns_);
    std::swap(reset_reason_, other->reset_reason_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ModemStatus::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ModemStatus_descriptor_;
  metadata.reflection = ModemStatus_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ModemSms::kNumberFieldNumber;
const int ModemSms::kTimestampFieldNumber;
const int ModemSms::kContentFieldNumber;
#endif  // !_MSC_VER

ModemSms::ModemSms()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:ecu.lapi.pb.ModemSms)
}

void ModemSms::InitAsDefaultInstance() {
}

ModemSms::ModemSms(const ModemSms& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:ecu.lapi.pb.ModemSms)
}

void ModemSms::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  number_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  timestamp_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  content_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ModemSms::~ModemSms() {
  // @@protoc_insertion_point(destructor:ecu.lapi.pb.ModemSms)
  SharedDtor();
}

void ModemSms::SharedDtor() {
  if (number_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete number_;
  }
  if (timestamp_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete timestamp_;
  }
  if (content_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete content_;
  }
  if (this != default_instance_) {
  }
}

void ModemSms::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ModemSms::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ModemSms_descriptor_;
}

const ModemSms& ModemSms::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_modem_2eproto();
  return *default_instance_;
}

ModemSms* ModemSms::default_instance_ = NULL;

ModemSms* ModemSms::New() const {
  return new ModemSms;
}

void ModemSms::Clear() {
  if (_has_bits_[0 / 32] & 7) {
    if (has_number()) {
      if (number_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        number_->clear();
      }
    }
    if (has_timestamp()) {
      if (timestamp_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        timestamp_->clear();
      }
    }
    if (has_content()) {
      if (content_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        content_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ModemSms::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:ecu.lapi.pb.ModemSms)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string number = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_number()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->number().data(), this->number().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "number");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_timestamp;
        break;
      }

      // optional string timestamp = 2;
      case 2: {
        if (tag == 18) {
         parse_timestamp:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_timestamp()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->timestamp().data(), this->timestamp().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "timestamp");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_content;
        break;
      }

      // optional string content = 3;
      case 3: {
        if (tag == 26) {
         parse_content:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_content()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->content().data(), this->content().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "content");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ecu.lapi.pb.ModemSms)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ecu.lapi.pb.ModemSms)
  return false;
#undef DO_
}

void ModemSms::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ecu.lapi.pb.ModemSms)
  // optional string number = 1;
  if (has_number()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->number().data(), this->number().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "number");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->number(), output);
  }

  // optional string timestamp = 2;
  if (has_timestamp()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->timestamp().data(), this->timestamp().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "timestamp");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->timestamp(), output);
  }

  // optional string content = 3;
  if (has_content()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->content().data(), this->content().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "content");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->content(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:ecu.lapi.pb.ModemSms)
}

::google::protobuf::uint8* ModemSms::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:ecu.lapi.pb.ModemSms)
  // optional string number = 1;
  if (has_number()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->number().data(), this->number().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "number");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->number(), target);
  }

  // optional string timestamp = 2;
  if (has_timestamp()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->timestamp().data(), this->timestamp().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "timestamp");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->timestamp(), target);
  }

  // optional string content = 3;
  if (has_content()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->content().data(), this->content().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "content");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->content(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ecu.lapi.pb.ModemSms)
  return target;
}

int ModemSms::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string number = 1;
    if (has_number()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->number());
    }

    // optional string timestamp = 2;
    if (has_timestamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->timestamp());
    }

    // optional string content = 3;
    if (has_content()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->content());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ModemSms::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ModemSms* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ModemSms*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ModemSms::MergeFrom(const ModemSms& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_number()) {
      set_number(from.number());
    }
    if (from.has_timestamp()) {
      set_timestamp(from.timestamp());
    }
    if (from.has_content()) {
      set_content(from.content());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ModemSms::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ModemSms::CopyFrom(const ModemSms& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModemSms::IsInitialized() const {

  return true;
}

void ModemSms::Swap(ModemSms* other) {
  if (other != this) {
    std::swap(number_, other->number_);
    std::swap(timestamp_, other->timestamp_);
    std::swap(content_, other->content_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ModemSms::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ModemSms_descriptor_;
  metadata.reflection = ModemSms_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb
}  // namespace lapi
}  // namespace ecu

// @@protoc_insertion_point(global_scope)
