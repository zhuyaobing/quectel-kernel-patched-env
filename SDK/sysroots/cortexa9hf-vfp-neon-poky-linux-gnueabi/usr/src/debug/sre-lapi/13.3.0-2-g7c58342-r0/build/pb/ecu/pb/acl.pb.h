// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: acl.proto

#ifndef PROTOBUF_acl_2eproto__INCLUDED
#define PROTOBUF_acl_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace ecu {
namespace lapi {
namespace pb {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_acl_2eproto();
void protobuf_AssignDesc_acl_2eproto();
void protobuf_ShutdownFile_acl_2eproto();

class AclInterface;
class AclInterfaceRequest;
class AclInterfaceResponse;
class AclIfMessage;

enum AclInterface_Protocol {
  AclInterface_Protocol_P_UNKNOWN = 0,
  AclInterface_Protocol_P_MQTT = 1,
  AclInterface_Protocol_P_WEBSOCKET = 2,
  AclInterface_Protocol_P_REST = 3
};
bool AclInterface_Protocol_IsValid(int value);
const AclInterface_Protocol AclInterface_Protocol_Protocol_MIN = AclInterface_Protocol_P_UNKNOWN;
const AclInterface_Protocol AclInterface_Protocol_Protocol_MAX = AclInterface_Protocol_P_REST;
const int AclInterface_Protocol_Protocol_ARRAYSIZE = AclInterface_Protocol_Protocol_MAX + 1;

const ::google::protobuf::EnumDescriptor* AclInterface_Protocol_descriptor();
inline const ::std::string& AclInterface_Protocol_Name(AclInterface_Protocol value) {
  return ::google::protobuf::internal::NameOfEnum(
    AclInterface_Protocol_descriptor(), value);
}
inline bool AclInterface_Protocol_Parse(
    const ::std::string& name, AclInterface_Protocol* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AclInterface_Protocol>(
    AclInterface_Protocol_descriptor(), name, value);
}
enum AclInterfaceRequest_Action {
  AclInterfaceRequest_Action_ACT_NONE = 0,
  AclInterfaceRequest_Action_ACT_NEW_USER = 1,
  AclInterfaceRequest_Action_ACT_RM_USER = 2,
  AclInterfaceRequest_Action_ACT_NEW_ACL = 3
};
bool AclInterfaceRequest_Action_IsValid(int value);
const AclInterfaceRequest_Action AclInterfaceRequest_Action_Action_MIN = AclInterfaceRequest_Action_ACT_NONE;
const AclInterfaceRequest_Action AclInterfaceRequest_Action_Action_MAX = AclInterfaceRequest_Action_ACT_NEW_ACL;
const int AclInterfaceRequest_Action_Action_ARRAYSIZE = AclInterfaceRequest_Action_Action_MAX + 1;

const ::google::protobuf::EnumDescriptor* AclInterfaceRequest_Action_descriptor();
inline const ::std::string& AclInterfaceRequest_Action_Name(AclInterfaceRequest_Action value) {
  return ::google::protobuf::internal::NameOfEnum(
    AclInterfaceRequest_Action_descriptor(), value);
}
inline bool AclInterfaceRequest_Action_Parse(
    const ::std::string& name, AclInterfaceRequest_Action* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AclInterfaceRequest_Action>(
    AclInterfaceRequest_Action_descriptor(), name, value);
}
enum AclInterfaceResponse_StatusCode {
  AclInterfaceResponse_StatusCode_SC_UNKNOWN_ERROR = 0,
  AclInterfaceResponse_StatusCode_SC_OK = 1,
  AclInterfaceResponse_StatusCode_SC_TIMEOUT = 2,
  AclInterfaceResponse_StatusCode_SC_REJECTED = 7,
  AclInterfaceResponse_StatusCode_SC_PB_SER_ERROR = 20
};
bool AclInterfaceResponse_StatusCode_IsValid(int value);
const AclInterfaceResponse_StatusCode AclInterfaceResponse_StatusCode_StatusCode_MIN = AclInterfaceResponse_StatusCode_SC_UNKNOWN_ERROR;
const AclInterfaceResponse_StatusCode AclInterfaceResponse_StatusCode_StatusCode_MAX = AclInterfaceResponse_StatusCode_SC_PB_SER_ERROR;
const int AclInterfaceResponse_StatusCode_StatusCode_ARRAYSIZE = AclInterfaceResponse_StatusCode_StatusCode_MAX + 1;

const ::google::protobuf::EnumDescriptor* AclInterfaceResponse_StatusCode_descriptor();
inline const ::std::string& AclInterfaceResponse_StatusCode_Name(AclInterfaceResponse_StatusCode value) {
  return ::google::protobuf::internal::NameOfEnum(
    AclInterfaceResponse_StatusCode_descriptor(), value);
}
inline bool AclInterfaceResponse_StatusCode_Parse(
    const ::std::string& name, AclInterfaceResponse_StatusCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AclInterfaceResponse_StatusCode>(
    AclInterfaceResponse_StatusCode_descriptor(), name, value);
}
// ===================================================================

class AclInterface : public ::google::protobuf::Message {
 public:
  AclInterface();
  virtual ~AclInterface();

  AclInterface(const AclInterface& from);

  inline AclInterface& operator=(const AclInterface& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AclInterface& default_instance();

  void Swap(AclInterface* other);

  // implements Message ----------------------------------------------

  AclInterface* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AclInterface& from);
  void MergeFrom(const AclInterface& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef AclInterface_Protocol Protocol;
  static const Protocol P_UNKNOWN = AclInterface_Protocol_P_UNKNOWN;
  static const Protocol P_MQTT = AclInterface_Protocol_P_MQTT;
  static const Protocol P_WEBSOCKET = AclInterface_Protocol_P_WEBSOCKET;
  static const Protocol P_REST = AclInterface_Protocol_P_REST;
  static inline bool Protocol_IsValid(int value) {
    return AclInterface_Protocol_IsValid(value);
  }
  static const Protocol Protocol_MIN =
    AclInterface_Protocol_Protocol_MIN;
  static const Protocol Protocol_MAX =
    AclInterface_Protocol_Protocol_MAX;
  static const int Protocol_ARRAYSIZE =
    AclInterface_Protocol_Protocol_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Protocol_descriptor() {
    return AclInterface_Protocol_descriptor();
  }
  static inline const ::std::string& Protocol_Name(Protocol value) {
    return AclInterface_Protocol_Name(value);
  }
  static inline bool Protocol_Parse(const ::std::string& name,
      Protocol* value) {
    return AclInterface_Protocol_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .ecu.lapi.pb.AclInterface.Protocol protocol = 1;
  inline bool has_protocol() const;
  inline void clear_protocol();
  static const int kProtocolFieldNumber = 1;
  inline ::ecu::lapi::pb::AclInterface_Protocol protocol() const;
  inline void set_protocol(::ecu::lapi::pb::AclInterface_Protocol value);

  // @@protoc_insertion_point(class_scope:ecu.lapi.pb.AclInterface)
 private:
  inline void set_has_protocol();
  inline void clear_has_protocol();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int protocol_;
  friend void  protobuf_AddDesc_acl_2eproto();
  friend void protobuf_AssignDesc_acl_2eproto();
  friend void protobuf_ShutdownFile_acl_2eproto();

  void InitAsDefaultInstance();
  static AclInterface* default_instance_;
};
// -------------------------------------------------------------------

class AclInterfaceRequest : public ::google::protobuf::Message {
 public:
  AclInterfaceRequest();
  virtual ~AclInterfaceRequest();

  AclInterfaceRequest(const AclInterfaceRequest& from);

  inline AclInterfaceRequest& operator=(const AclInterfaceRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AclInterfaceRequest& default_instance();

  void Swap(AclInterfaceRequest* other);

  // implements Message ----------------------------------------------

  AclInterfaceRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AclInterfaceRequest& from);
  void MergeFrom(const AclInterfaceRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef AclInterfaceRequest_Action Action;
  static const Action ACT_NONE = AclInterfaceRequest_Action_ACT_NONE;
  static const Action ACT_NEW_USER = AclInterfaceRequest_Action_ACT_NEW_USER;
  static const Action ACT_RM_USER = AclInterfaceRequest_Action_ACT_RM_USER;
  static const Action ACT_NEW_ACL = AclInterfaceRequest_Action_ACT_NEW_ACL;
  static inline bool Action_IsValid(int value) {
    return AclInterfaceRequest_Action_IsValid(value);
  }
  static const Action Action_MIN =
    AclInterfaceRequest_Action_Action_MIN;
  static const Action Action_MAX =
    AclInterfaceRequest_Action_Action_MAX;
  static const int Action_ARRAYSIZE =
    AclInterfaceRequest_Action_Action_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Action_descriptor() {
    return AclInterfaceRequest_Action_descriptor();
  }
  static inline const ::std::string& Action_Name(Action value) {
    return AclInterfaceRequest_Action_Name(value);
  }
  static inline bool Action_Parse(const ::std::string& name,
      Action* value) {
    return AclInterfaceRequest_Action_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string client_name = 1;
  inline bool has_client_name() const;
  inline void clear_client_name();
  static const int kClientNameFieldNumber = 1;
  inline const ::std::string& client_name() const;
  inline void set_client_name(const ::std::string& value);
  inline void set_client_name(const char* value);
  inline void set_client_name(const char* value, size_t size);
  inline ::std::string* mutable_client_name();
  inline ::std::string* release_client_name();
  inline void set_allocated_client_name(::std::string* client_name);

  // optional uint32 timeout_ms = 2 [default = 500000];
  inline bool has_timeout_ms() const;
  inline void clear_timeout_ms();
  static const int kTimeoutMsFieldNumber = 2;
  inline ::google::protobuf::uint32 timeout_ms() const;
  inline void set_timeout_ms(::google::protobuf::uint32 value);

  // optional .ecu.lapi.pb.AclInterfaceRequest.Action action = 3;
  inline bool has_action() const;
  inline void clear_action();
  static const int kActionFieldNumber = 3;
  inline ::ecu::lapi::pb::AclInterfaceRequest_Action action() const;
  inline void set_action(::ecu::lapi::pb::AclInterfaceRequest_Action value);

  // optional string user = 4;
  inline bool has_user() const;
  inline void clear_user();
  static const int kUserFieldNumber = 4;
  inline const ::std::string& user() const;
  inline void set_user(const ::std::string& value);
  inline void set_user(const char* value);
  inline void set_user(const char* value, size_t size);
  inline ::std::string* mutable_user();
  inline ::std::string* release_user();
  inline void set_allocated_user(::std::string* user);

  // optional string password = 5;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 5;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // optional uint32 port = 6;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 6;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);

  // repeated string sub_topics = 7;
  inline int sub_topics_size() const;
  inline void clear_sub_topics();
  static const int kSubTopicsFieldNumber = 7;
  inline const ::std::string& sub_topics(int index) const;
  inline ::std::string* mutable_sub_topics(int index);
  inline void set_sub_topics(int index, const ::std::string& value);
  inline void set_sub_topics(int index, const char* value);
  inline void set_sub_topics(int index, const char* value, size_t size);
  inline ::std::string* add_sub_topics();
  inline void add_sub_topics(const ::std::string& value);
  inline void add_sub_topics(const char* value);
  inline void add_sub_topics(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& sub_topics() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_sub_topics();

  // repeated string pub_topics = 8;
  inline int pub_topics_size() const;
  inline void clear_pub_topics();
  static const int kPubTopicsFieldNumber = 8;
  inline const ::std::string& pub_topics(int index) const;
  inline ::std::string* mutable_pub_topics(int index);
  inline void set_pub_topics(int index, const ::std::string& value);
  inline void set_pub_topics(int index, const char* value);
  inline void set_pub_topics(int index, const char* value, size_t size);
  inline ::std::string* add_pub_topics();
  inline void add_pub_topics(const ::std::string& value);
  inline void add_pub_topics(const char* value);
  inline void add_pub_topics(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& pub_topics() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_pub_topics();

  // @@protoc_insertion_point(class_scope:ecu.lapi.pb.AclInterfaceRequest)
 private:
  inline void set_has_client_name();
  inline void clear_has_client_name();
  inline void set_has_timeout_ms();
  inline void clear_has_timeout_ms();
  inline void set_has_action();
  inline void clear_has_action();
  inline void set_has_user();
  inline void clear_has_user();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_port();
  inline void clear_has_port();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* client_name_;
  ::google::protobuf::uint32 timeout_ms_;
  int action_;
  ::std::string* user_;
  ::std::string* password_;
  ::google::protobuf::RepeatedPtrField< ::std::string> sub_topics_;
  ::google::protobuf::RepeatedPtrField< ::std::string> pub_topics_;
  ::google::protobuf::uint32 port_;
  friend void  protobuf_AddDesc_acl_2eproto();
  friend void protobuf_AssignDesc_acl_2eproto();
  friend void protobuf_ShutdownFile_acl_2eproto();

  void InitAsDefaultInstance();
  static AclInterfaceRequest* default_instance_;
};
// -------------------------------------------------------------------

class AclInterfaceResponse : public ::google::protobuf::Message {
 public:
  AclInterfaceResponse();
  virtual ~AclInterfaceResponse();

  AclInterfaceResponse(const AclInterfaceResponse& from);

  inline AclInterfaceResponse& operator=(const AclInterfaceResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AclInterfaceResponse& default_instance();

  void Swap(AclInterfaceResponse* other);

  // implements Message ----------------------------------------------

  AclInterfaceResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AclInterfaceResponse& from);
  void MergeFrom(const AclInterfaceResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef AclInterfaceResponse_StatusCode StatusCode;
  static const StatusCode SC_UNKNOWN_ERROR = AclInterfaceResponse_StatusCode_SC_UNKNOWN_ERROR;
  static const StatusCode SC_OK = AclInterfaceResponse_StatusCode_SC_OK;
  static const StatusCode SC_TIMEOUT = AclInterfaceResponse_StatusCode_SC_TIMEOUT;
  static const StatusCode SC_REJECTED = AclInterfaceResponse_StatusCode_SC_REJECTED;
  static const StatusCode SC_PB_SER_ERROR = AclInterfaceResponse_StatusCode_SC_PB_SER_ERROR;
  static inline bool StatusCode_IsValid(int value) {
    return AclInterfaceResponse_StatusCode_IsValid(value);
  }
  static const StatusCode StatusCode_MIN =
    AclInterfaceResponse_StatusCode_StatusCode_MIN;
  static const StatusCode StatusCode_MAX =
    AclInterfaceResponse_StatusCode_StatusCode_MAX;
  static const int StatusCode_ARRAYSIZE =
    AclInterfaceResponse_StatusCode_StatusCode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  StatusCode_descriptor() {
    return AclInterfaceResponse_StatusCode_descriptor();
  }
  static inline const ::std::string& StatusCode_Name(StatusCode value) {
    return AclInterfaceResponse_StatusCode_Name(value);
  }
  static inline bool StatusCode_Parse(const ::std::string& name,
      StatusCode* value) {
    return AclInterfaceResponse_StatusCode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .ecu.lapi.pb.AclInterfaceResponse.StatusCode status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::ecu::lapi::pb::AclInterfaceResponse_StatusCode status() const;
  inline void set_status(::ecu::lapi::pb::AclInterfaceResponse_StatusCode value);

  // @@protoc_insertion_point(class_scope:ecu.lapi.pb.AclInterfaceResponse)
 private:
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int status_;
  friend void  protobuf_AddDesc_acl_2eproto();
  friend void protobuf_AssignDesc_acl_2eproto();
  friend void protobuf_ShutdownFile_acl_2eproto();

  void InitAsDefaultInstance();
  static AclInterfaceResponse* default_instance_;
};
// -------------------------------------------------------------------

class AclIfMessage : public ::google::protobuf::Message {
 public:
  AclIfMessage();
  virtual ~AclIfMessage();

  AclIfMessage(const AclIfMessage& from);

  inline AclIfMessage& operator=(const AclIfMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AclIfMessage& default_instance();

  void Swap(AclIfMessage* other);

  // implements Message ----------------------------------------------

  AclIfMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AclIfMessage& from);
  void MergeFrom(const AclIfMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ecu.lapi.pb.AclInterface interface = 1;
  inline bool has_interface() const;
  inline void clear_interface();
  static const int kInterfaceFieldNumber = 1;
  inline const ::ecu::lapi::pb::AclInterface& interface() const;
  inline ::ecu::lapi::pb::AclInterface* mutable_interface();
  inline ::ecu::lapi::pb::AclInterface* release_interface();
  inline void set_allocated_interface(::ecu::lapi::pb::AclInterface* interface);

  // optional .ecu.lapi.pb.AclInterfaceRequest request = 3;
  inline bool has_request() const;
  inline void clear_request();
  static const int kRequestFieldNumber = 3;
  inline const ::ecu::lapi::pb::AclInterfaceRequest& request() const;
  inline ::ecu::lapi::pb::AclInterfaceRequest* mutable_request();
  inline ::ecu::lapi::pb::AclInterfaceRequest* release_request();
  inline void set_allocated_request(::ecu::lapi::pb::AclInterfaceRequest* request);

  // optional .ecu.lapi.pb.AclInterfaceResponse response = 4;
  inline bool has_response() const;
  inline void clear_response();
  static const int kResponseFieldNumber = 4;
  inline const ::ecu::lapi::pb::AclInterfaceResponse& response() const;
  inline ::ecu::lapi::pb::AclInterfaceResponse* mutable_response();
  inline ::ecu::lapi::pb::AclInterfaceResponse* release_response();
  inline void set_allocated_response(::ecu::lapi::pb::AclInterfaceResponse* response);

  // @@protoc_insertion_point(class_scope:ecu.lapi.pb.AclIfMessage)
 private:
  inline void set_has_interface();
  inline void clear_has_interface();
  inline void set_has_request();
  inline void clear_has_request();
  inline void set_has_response();
  inline void clear_has_response();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::ecu::lapi::pb::AclInterface* interface_;
  ::ecu::lapi::pb::AclInterfaceRequest* request_;
  ::ecu::lapi::pb::AclInterfaceResponse* response_;
  friend void  protobuf_AddDesc_acl_2eproto();
  friend void protobuf_AssignDesc_acl_2eproto();
  friend void protobuf_ShutdownFile_acl_2eproto();

  void InitAsDefaultInstance();
  static AclIfMessage* default_instance_;
};
// ===================================================================


// ===================================================================

// AclInterface

// optional .ecu.lapi.pb.AclInterface.Protocol protocol = 1;
inline bool AclInterface::has_protocol() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AclInterface::set_has_protocol() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AclInterface::clear_has_protocol() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AclInterface::clear_protocol() {
  protocol_ = 0;
  clear_has_protocol();
}
inline ::ecu::lapi::pb::AclInterface_Protocol AclInterface::protocol() const {
  // @@protoc_insertion_point(field_get:ecu.lapi.pb.AclInterface.protocol)
  return static_cast< ::ecu::lapi::pb::AclInterface_Protocol >(protocol_);
}
inline void AclInterface::set_protocol(::ecu::lapi::pb::AclInterface_Protocol value) {
  assert(::ecu::lapi::pb::AclInterface_Protocol_IsValid(value));
  set_has_protocol();
  protocol_ = value;
  // @@protoc_insertion_point(field_set:ecu.lapi.pb.AclInterface.protocol)
}

// -------------------------------------------------------------------

// AclInterfaceRequest

// optional string client_name = 1;
inline bool AclInterfaceRequest::has_client_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AclInterfaceRequest::set_has_client_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AclInterfaceRequest::clear_has_client_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AclInterfaceRequest::clear_client_name() {
  if (client_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_name_->clear();
  }
  clear_has_client_name();
}
inline const ::std::string& AclInterfaceRequest::client_name() const {
  // @@protoc_insertion_point(field_get:ecu.lapi.pb.AclInterfaceRequest.client_name)
  return *client_name_;
}
inline void AclInterfaceRequest::set_client_name(const ::std::string& value) {
  set_has_client_name();
  if (client_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_name_ = new ::std::string;
  }
  client_name_->assign(value);
  // @@protoc_insertion_point(field_set:ecu.lapi.pb.AclInterfaceRequest.client_name)
}
inline void AclInterfaceRequest::set_client_name(const char* value) {
  set_has_client_name();
  if (client_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_name_ = new ::std::string;
  }
  client_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:ecu.lapi.pb.AclInterfaceRequest.client_name)
}
inline void AclInterfaceRequest::set_client_name(const char* value, size_t size) {
  set_has_client_name();
  if (client_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_name_ = new ::std::string;
  }
  client_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ecu.lapi.pb.AclInterfaceRequest.client_name)
}
inline ::std::string* AclInterfaceRequest::mutable_client_name() {
  set_has_client_name();
  if (client_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ecu.lapi.pb.AclInterfaceRequest.client_name)
  return client_name_;
}
inline ::std::string* AclInterfaceRequest::release_client_name() {
  clear_has_client_name();
  if (client_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = client_name_;
    client_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AclInterfaceRequest::set_allocated_client_name(::std::string* client_name) {
  if (client_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete client_name_;
  }
  if (client_name) {
    set_has_client_name();
    client_name_ = client_name;
  } else {
    clear_has_client_name();
    client_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ecu.lapi.pb.AclInterfaceRequest.client_name)
}

// optional uint32 timeout_ms = 2 [default = 500000];
inline bool AclInterfaceRequest::has_timeout_ms() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AclInterfaceRequest::set_has_timeout_ms() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AclInterfaceRequest::clear_has_timeout_ms() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AclInterfaceRequest::clear_timeout_ms() {
  timeout_ms_ = 500000u;
  clear_has_timeout_ms();
}
inline ::google::protobuf::uint32 AclInterfaceRequest::timeout_ms() const {
  // @@protoc_insertion_point(field_get:ecu.lapi.pb.AclInterfaceRequest.timeout_ms)
  return timeout_ms_;
}
inline void AclInterfaceRequest::set_timeout_ms(::google::protobuf::uint32 value) {
  set_has_timeout_ms();
  timeout_ms_ = value;
  // @@protoc_insertion_point(field_set:ecu.lapi.pb.AclInterfaceRequest.timeout_ms)
}

// optional .ecu.lapi.pb.AclInterfaceRequest.Action action = 3;
inline bool AclInterfaceRequest::has_action() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AclInterfaceRequest::set_has_action() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AclInterfaceRequest::clear_has_action() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AclInterfaceRequest::clear_action() {
  action_ = 0;
  clear_has_action();
}
inline ::ecu::lapi::pb::AclInterfaceRequest_Action AclInterfaceRequest::action() const {
  // @@protoc_insertion_point(field_get:ecu.lapi.pb.AclInterfaceRequest.action)
  return static_cast< ::ecu::lapi::pb::AclInterfaceRequest_Action >(action_);
}
inline void AclInterfaceRequest::set_action(::ecu::lapi::pb::AclInterfaceRequest_Action value) {
  assert(::ecu::lapi::pb::AclInterfaceRequest_Action_IsValid(value));
  set_has_action();
  action_ = value;
  // @@protoc_insertion_point(field_set:ecu.lapi.pb.AclInterfaceRequest.action)
}

// optional string user = 4;
inline bool AclInterfaceRequest::has_user() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AclInterfaceRequest::set_has_user() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AclInterfaceRequest::clear_has_user() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AclInterfaceRequest::clear_user() {
  if (user_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_->clear();
  }
  clear_has_user();
}
inline const ::std::string& AclInterfaceRequest::user() const {
  // @@protoc_insertion_point(field_get:ecu.lapi.pb.AclInterfaceRequest.user)
  return *user_;
}
inline void AclInterfaceRequest::set_user(const ::std::string& value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_ = new ::std::string;
  }
  user_->assign(value);
  // @@protoc_insertion_point(field_set:ecu.lapi.pb.AclInterfaceRequest.user)
}
inline void AclInterfaceRequest::set_user(const char* value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_ = new ::std::string;
  }
  user_->assign(value);
  // @@protoc_insertion_point(field_set_char:ecu.lapi.pb.AclInterfaceRequest.user)
}
inline void AclInterfaceRequest::set_user(const char* value, size_t size) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_ = new ::std::string;
  }
  user_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ecu.lapi.pb.AclInterfaceRequest.user)
}
inline ::std::string* AclInterfaceRequest::mutable_user() {
  set_has_user();
  if (user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ecu.lapi.pb.AclInterfaceRequest.user)
  return user_;
}
inline ::std::string* AclInterfaceRequest::release_user() {
  clear_has_user();
  if (user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = user_;
    user_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AclInterfaceRequest::set_allocated_user(::std::string* user) {
  if (user_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_;
  }
  if (user) {
    set_has_user();
    user_ = user;
  } else {
    clear_has_user();
    user_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ecu.lapi.pb.AclInterfaceRequest.user)
}

// optional string password = 5;
inline bool AclInterfaceRequest::has_password() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AclInterfaceRequest::set_has_password() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AclInterfaceRequest::clear_has_password() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AclInterfaceRequest::clear_password() {
  if (password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& AclInterfaceRequest::password() const {
  // @@protoc_insertion_point(field_get:ecu.lapi.pb.AclInterfaceRequest.password)
  return *password_;
}
inline void AclInterfaceRequest::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(value);
  // @@protoc_insertion_point(field_set:ecu.lapi.pb.AclInterfaceRequest.password)
}
inline void AclInterfaceRequest::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(value);
  // @@protoc_insertion_point(field_set_char:ecu.lapi.pb.AclInterfaceRequest.password)
}
inline void AclInterfaceRequest::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ecu.lapi.pb.AclInterfaceRequest.password)
}
inline ::std::string* AclInterfaceRequest::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ecu.lapi.pb.AclInterfaceRequest.password)
  return password_;
}
inline ::std::string* AclInterfaceRequest::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AclInterfaceRequest::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ecu.lapi.pb.AclInterfaceRequest.password)
}

// optional uint32 port = 6;
inline bool AclInterfaceRequest::has_port() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AclInterfaceRequest::set_has_port() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AclInterfaceRequest::clear_has_port() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AclInterfaceRequest::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 AclInterfaceRequest::port() const {
  // @@protoc_insertion_point(field_get:ecu.lapi.pb.AclInterfaceRequest.port)
  return port_;
}
inline void AclInterfaceRequest::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
  // @@protoc_insertion_point(field_set:ecu.lapi.pb.AclInterfaceRequest.port)
}

// repeated string sub_topics = 7;
inline int AclInterfaceRequest::sub_topics_size() const {
  return sub_topics_.size();
}
inline void AclInterfaceRequest::clear_sub_topics() {
  sub_topics_.Clear();
}
inline const ::std::string& AclInterfaceRequest::sub_topics(int index) const {
  // @@protoc_insertion_point(field_get:ecu.lapi.pb.AclInterfaceRequest.sub_topics)
  return sub_topics_.Get(index);
}
inline ::std::string* AclInterfaceRequest::mutable_sub_topics(int index) {
  // @@protoc_insertion_point(field_mutable:ecu.lapi.pb.AclInterfaceRequest.sub_topics)
  return sub_topics_.Mutable(index);
}
inline void AclInterfaceRequest::set_sub_topics(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:ecu.lapi.pb.AclInterfaceRequest.sub_topics)
  sub_topics_.Mutable(index)->assign(value);
}
inline void AclInterfaceRequest::set_sub_topics(int index, const char* value) {
  sub_topics_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ecu.lapi.pb.AclInterfaceRequest.sub_topics)
}
inline void AclInterfaceRequest::set_sub_topics(int index, const char* value, size_t size) {
  sub_topics_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ecu.lapi.pb.AclInterfaceRequest.sub_topics)
}
inline ::std::string* AclInterfaceRequest::add_sub_topics() {
  return sub_topics_.Add();
}
inline void AclInterfaceRequest::add_sub_topics(const ::std::string& value) {
  sub_topics_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ecu.lapi.pb.AclInterfaceRequest.sub_topics)
}
inline void AclInterfaceRequest::add_sub_topics(const char* value) {
  sub_topics_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ecu.lapi.pb.AclInterfaceRequest.sub_topics)
}
inline void AclInterfaceRequest::add_sub_topics(const char* value, size_t size) {
  sub_topics_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ecu.lapi.pb.AclInterfaceRequest.sub_topics)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
AclInterfaceRequest::sub_topics() const {
  // @@protoc_insertion_point(field_list:ecu.lapi.pb.AclInterfaceRequest.sub_topics)
  return sub_topics_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
AclInterfaceRequest::mutable_sub_topics() {
  // @@protoc_insertion_point(field_mutable_list:ecu.lapi.pb.AclInterfaceRequest.sub_topics)
  return &sub_topics_;
}

// repeated string pub_topics = 8;
inline int AclInterfaceRequest::pub_topics_size() const {
  return pub_topics_.size();
}
inline void AclInterfaceRequest::clear_pub_topics() {
  pub_topics_.Clear();
}
inline const ::std::string& AclInterfaceRequest::pub_topics(int index) const {
  // @@protoc_insertion_point(field_get:ecu.lapi.pb.AclInterfaceRequest.pub_topics)
  return pub_topics_.Get(index);
}
inline ::std::string* AclInterfaceRequest::mutable_pub_topics(int index) {
  // @@protoc_insertion_point(field_mutable:ecu.lapi.pb.AclInterfaceRequest.pub_topics)
  return pub_topics_.Mutable(index);
}
inline void AclInterfaceRequest::set_pub_topics(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:ecu.lapi.pb.AclInterfaceRequest.pub_topics)
  pub_topics_.Mutable(index)->assign(value);
}
inline void AclInterfaceRequest::set_pub_topics(int index, const char* value) {
  pub_topics_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ecu.lapi.pb.AclInterfaceRequest.pub_topics)
}
inline void AclInterfaceRequest::set_pub_topics(int index, const char* value, size_t size) {
  pub_topics_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ecu.lapi.pb.AclInterfaceRequest.pub_topics)
}
inline ::std::string* AclInterfaceRequest::add_pub_topics() {
  return pub_topics_.Add();
}
inline void AclInterfaceRequest::add_pub_topics(const ::std::string& value) {
  pub_topics_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ecu.lapi.pb.AclInterfaceRequest.pub_topics)
}
inline void AclInterfaceRequest::add_pub_topics(const char* value) {
  pub_topics_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ecu.lapi.pb.AclInterfaceRequest.pub_topics)
}
inline void AclInterfaceRequest::add_pub_topics(const char* value, size_t size) {
  pub_topics_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ecu.lapi.pb.AclInterfaceRequest.pub_topics)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
AclInterfaceRequest::pub_topics() const {
  // @@protoc_insertion_point(field_list:ecu.lapi.pb.AclInterfaceRequest.pub_topics)
  return pub_topics_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
AclInterfaceRequest::mutable_pub_topics() {
  // @@protoc_insertion_point(field_mutable_list:ecu.lapi.pb.AclInterfaceRequest.pub_topics)
  return &pub_topics_;
}

// -------------------------------------------------------------------

// AclInterfaceResponse

// optional .ecu.lapi.pb.AclInterfaceResponse.StatusCode status = 1;
inline bool AclInterfaceResponse::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AclInterfaceResponse::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AclInterfaceResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AclInterfaceResponse::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::ecu::lapi::pb::AclInterfaceResponse_StatusCode AclInterfaceResponse::status() const {
  // @@protoc_insertion_point(field_get:ecu.lapi.pb.AclInterfaceResponse.status)
  return static_cast< ::ecu::lapi::pb::AclInterfaceResponse_StatusCode >(status_);
}
inline void AclInterfaceResponse::set_status(::ecu::lapi::pb::AclInterfaceResponse_StatusCode value) {
  assert(::ecu::lapi::pb::AclInterfaceResponse_StatusCode_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:ecu.lapi.pb.AclInterfaceResponse.status)
}

// -------------------------------------------------------------------

// AclIfMessage

// optional .ecu.lapi.pb.AclInterface interface = 1;
inline bool AclIfMessage::has_interface() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AclIfMessage::set_has_interface() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AclIfMessage::clear_has_interface() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AclIfMessage::clear_interface() {
  if (interface_ != NULL) interface_->::ecu::lapi::pb::AclInterface::Clear();
  clear_has_interface();
}
inline const ::ecu::lapi::pb::AclInterface& AclIfMessage::interface() const {
  // @@protoc_insertion_point(field_get:ecu.lapi.pb.AclIfMessage.interface)
  return interface_ != NULL ? *interface_ : *default_instance_->interface_;
}
inline ::ecu::lapi::pb::AclInterface* AclIfMessage::mutable_interface() {
  set_has_interface();
  if (interface_ == NULL) interface_ = new ::ecu::lapi::pb::AclInterface;
  // @@protoc_insertion_point(field_mutable:ecu.lapi.pb.AclIfMessage.interface)
  return interface_;
}
inline ::ecu::lapi::pb::AclInterface* AclIfMessage::release_interface() {
  clear_has_interface();
  ::ecu::lapi::pb::AclInterface* temp = interface_;
  interface_ = NULL;
  return temp;
}
inline void AclIfMessage::set_allocated_interface(::ecu::lapi::pb::AclInterface* interface) {
  delete interface_;
  interface_ = interface;
  if (interface) {
    set_has_interface();
  } else {
    clear_has_interface();
  }
  // @@protoc_insertion_point(field_set_allocated:ecu.lapi.pb.AclIfMessage.interface)
}

// optional .ecu.lapi.pb.AclInterfaceRequest request = 3;
inline bool AclIfMessage::has_request() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AclIfMessage::set_has_request() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AclIfMessage::clear_has_request() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AclIfMessage::clear_request() {
  if (request_ != NULL) request_->::ecu::lapi::pb::AclInterfaceRequest::Clear();
  clear_has_request();
}
inline const ::ecu::lapi::pb::AclInterfaceRequest& AclIfMessage::request() const {
  // @@protoc_insertion_point(field_get:ecu.lapi.pb.AclIfMessage.request)
  return request_ != NULL ? *request_ : *default_instance_->request_;
}
inline ::ecu::lapi::pb::AclInterfaceRequest* AclIfMessage::mutable_request() {
  set_has_request();
  if (request_ == NULL) request_ = new ::ecu::lapi::pb::AclInterfaceRequest;
  // @@protoc_insertion_point(field_mutable:ecu.lapi.pb.AclIfMessage.request)
  return request_;
}
inline ::ecu::lapi::pb::AclInterfaceRequest* AclIfMessage::release_request() {
  clear_has_request();
  ::ecu::lapi::pb::AclInterfaceRequest* temp = request_;
  request_ = NULL;
  return temp;
}
inline void AclIfMessage::set_allocated_request(::ecu::lapi::pb::AclInterfaceRequest* request) {
  delete request_;
  request_ = request;
  if (request) {
    set_has_request();
  } else {
    clear_has_request();
  }
  // @@protoc_insertion_point(field_set_allocated:ecu.lapi.pb.AclIfMessage.request)
}

// optional .ecu.lapi.pb.AclInterfaceResponse response = 4;
inline bool AclIfMessage::has_response() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AclIfMessage::set_has_response() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AclIfMessage::clear_has_response() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AclIfMessage::clear_response() {
  if (response_ != NULL) response_->::ecu::lapi::pb::AclInterfaceResponse::Clear();
  clear_has_response();
}
inline const ::ecu::lapi::pb::AclInterfaceResponse& AclIfMessage::response() const {
  // @@protoc_insertion_point(field_get:ecu.lapi.pb.AclIfMessage.response)
  return response_ != NULL ? *response_ : *default_instance_->response_;
}
inline ::ecu::lapi::pb::AclInterfaceResponse* AclIfMessage::mutable_response() {
  set_has_response();
  if (response_ == NULL) response_ = new ::ecu::lapi::pb::AclInterfaceResponse;
  // @@protoc_insertion_point(field_mutable:ecu.lapi.pb.AclIfMessage.response)
  return response_;
}
inline ::ecu::lapi::pb::AclInterfaceResponse* AclIfMessage::release_response() {
  clear_has_response();
  ::ecu::lapi::pb::AclInterfaceResponse* temp = response_;
  response_ = NULL;
  return temp;
}
inline void AclIfMessage::set_allocated_response(::ecu::lapi::pb::AclInterfaceResponse* response) {
  delete response_;
  response_ = response;
  if (response) {
    set_has_response();
  } else {
    clear_has_response();
  }
  // @@protoc_insertion_point(field_set_allocated:ecu.lapi.pb.AclIfMessage.response)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb
}  // namespace lapi
}  // namespace ecu

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::ecu::lapi::pb::AclInterface_Protocol> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ecu::lapi::pb::AclInterface_Protocol>() {
  return ::ecu::lapi::pb::AclInterface_Protocol_descriptor();
}
template <> struct is_proto_enum< ::ecu::lapi::pb::AclInterfaceRequest_Action> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ecu::lapi::pb::AclInterfaceRequest_Action>() {
  return ::ecu::lapi::pb::AclInterfaceRequest_Action_descriptor();
}
template <> struct is_proto_enum< ::ecu::lapi::pb::AclInterfaceResponse_StatusCode> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ecu::lapi::pb::AclInterfaceResponse_StatusCode>() {
  return ::ecu::lapi::pb::AclInterfaceResponse_StatusCode_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_acl_2eproto__INCLUDED
