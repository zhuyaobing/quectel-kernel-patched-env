// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: uds.proto

#ifndef PROTOBUF_uds_2eproto__INCLUDED
#define PROTOBUF_uds_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace ecu {
namespace lapi {
namespace pb {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_uds_2eproto();
void protobuf_AssignDesc_uds_2eproto();
void protobuf_ShutdownFile_uds_2eproto();

class UdsInterface;
class UdsInterfaceAllocation;
class UdsInterfaceRequest;
class UdsInterfaceResponse;
class UdsInterfaceStatus;
class UdsIfMessage;

enum UdsInterface_TransportProtocol {
  UdsInterface_TransportProtocol_TP_UNKNOWN = 10,
  UdsInterface_TransportProtocol_TP_ISO = 0
};
bool UdsInterface_TransportProtocol_IsValid(int value);
const UdsInterface_TransportProtocol UdsInterface_TransportProtocol_TransportProtocol_MIN = UdsInterface_TransportProtocol_TP_ISO;
const UdsInterface_TransportProtocol UdsInterface_TransportProtocol_TransportProtocol_MAX = UdsInterface_TransportProtocol_TP_UNKNOWN;
const int UdsInterface_TransportProtocol_TransportProtocol_ARRAYSIZE = UdsInterface_TransportProtocol_TransportProtocol_MAX + 1;

const ::google::protobuf::EnumDescriptor* UdsInterface_TransportProtocol_descriptor();
inline const ::std::string& UdsInterface_TransportProtocol_Name(UdsInterface_TransportProtocol value) {
  return ::google::protobuf::internal::NameOfEnum(
    UdsInterface_TransportProtocol_descriptor(), value);
}
inline bool UdsInterface_TransportProtocol_Parse(
    const ::std::string& name, UdsInterface_TransportProtocol* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UdsInterface_TransportProtocol>(
    UdsInterface_TransportProtocol_descriptor(), name, value);
}
enum UdsInterface_PhysicalInterface {
  UdsInterface_PhysicalInterface_IF_UNKNOWN = 10,
  UdsInterface_PhysicalInterface_IF_CAN1 = 0,
  UdsInterface_PhysicalInterface_IF_CAN2 = 1
};
bool UdsInterface_PhysicalInterface_IsValid(int value);
const UdsInterface_PhysicalInterface UdsInterface_PhysicalInterface_PhysicalInterface_MIN = UdsInterface_PhysicalInterface_IF_CAN1;
const UdsInterface_PhysicalInterface UdsInterface_PhysicalInterface_PhysicalInterface_MAX = UdsInterface_PhysicalInterface_IF_UNKNOWN;
const int UdsInterface_PhysicalInterface_PhysicalInterface_ARRAYSIZE = UdsInterface_PhysicalInterface_PhysicalInterface_MAX + 1;

const ::google::protobuf::EnumDescriptor* UdsInterface_PhysicalInterface_descriptor();
inline const ::std::string& UdsInterface_PhysicalInterface_Name(UdsInterface_PhysicalInterface value) {
  return ::google::protobuf::internal::NameOfEnum(
    UdsInterface_PhysicalInterface_descriptor(), value);
}
inline bool UdsInterface_PhysicalInterface_Parse(
    const ::std::string& name, UdsInterface_PhysicalInterface* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UdsInterface_PhysicalInterface>(
    UdsInterface_PhysicalInterface_descriptor(), name, value);
}
enum UdsInterfaceRequest_FlowStatus {
  UdsInterfaceRequest_FlowStatus_FS_CTS = 0,
  UdsInterfaceRequest_FlowStatus_FS_WAIT = 1,
  UdsInterfaceRequest_FlowStatus_FS_SUPPRESS = 2,
  UdsInterfaceRequest_FlowStatus_FS_OVERFLOW = 3
};
bool UdsInterfaceRequest_FlowStatus_IsValid(int value);
const UdsInterfaceRequest_FlowStatus UdsInterfaceRequest_FlowStatus_FlowStatus_MIN = UdsInterfaceRequest_FlowStatus_FS_CTS;
const UdsInterfaceRequest_FlowStatus UdsInterfaceRequest_FlowStatus_FlowStatus_MAX = UdsInterfaceRequest_FlowStatus_FS_OVERFLOW;
const int UdsInterfaceRequest_FlowStatus_FlowStatus_ARRAYSIZE = UdsInterfaceRequest_FlowStatus_FlowStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* UdsInterfaceRequest_FlowStatus_descriptor();
inline const ::std::string& UdsInterfaceRequest_FlowStatus_Name(UdsInterfaceRequest_FlowStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    UdsInterfaceRequest_FlowStatus_descriptor(), value);
}
inline bool UdsInterfaceRequest_FlowStatus_Parse(
    const ::std::string& name, UdsInterfaceRequest_FlowStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UdsInterfaceRequest_FlowStatus>(
    UdsInterfaceRequest_FlowStatus_descriptor(), name, value);
}
enum UdsInterfaceResponse_StatusCode {
  UdsInterfaceResponse_StatusCode_UNKNOWN_ERROR = 30,
  UdsInterfaceResponse_StatusCode_OK = 1,
  UdsInterfaceResponse_StatusCode_TIMEOUT = 2,
  UdsInterfaceResponse_StatusCode_BUSY = 3,
  UdsInterfaceResponse_StatusCode_INTERRUPTED = 4,
  UdsInterfaceResponse_StatusCode_LENGTH_ERROR = 5,
  UdsInterfaceResponse_StatusCode_OVERFLOWED = 6,
  UdsInterfaceResponse_StatusCode_REJECTED = 7,
  UdsInterfaceResponse_StatusCode_RT_CAN_ERROR = 10,
  UdsInterfaceResponse_StatusCode_RT_POWEROFF = 11,
  UdsInterfaceResponse_StatusCode_RT_TIMEOUT = 12,
  UdsInterfaceResponse_StatusCode_RT_P2_TIMEOUT = 13,
  UdsInterfaceResponse_StatusCode_RT_P2STAR_TIMEOUT = 14,
  UdsInterfaceResponse_StatusCode_LINUX_IF_NOT_ALLOC = 20,
  UdsInterfaceResponse_StatusCode_LINUX_TX_ERROR = 21,
  UdsInterfaceResponse_StatusCode_LINUX_PB_SER_ERROR = 22,
  UdsInterfaceResponse_StatusCode_LINUX_UNKNOWN_ERROR = 23
};
bool UdsInterfaceResponse_StatusCode_IsValid(int value);
const UdsInterfaceResponse_StatusCode UdsInterfaceResponse_StatusCode_StatusCode_MIN = UdsInterfaceResponse_StatusCode_OK;
const UdsInterfaceResponse_StatusCode UdsInterfaceResponse_StatusCode_StatusCode_MAX = UdsInterfaceResponse_StatusCode_UNKNOWN_ERROR;
const int UdsInterfaceResponse_StatusCode_StatusCode_ARRAYSIZE = UdsInterfaceResponse_StatusCode_StatusCode_MAX + 1;

const ::google::protobuf::EnumDescriptor* UdsInterfaceResponse_StatusCode_descriptor();
inline const ::std::string& UdsInterfaceResponse_StatusCode_Name(UdsInterfaceResponse_StatusCode value) {
  return ::google::protobuf::internal::NameOfEnum(
    UdsInterfaceResponse_StatusCode_descriptor(), value);
}
inline bool UdsInterfaceResponse_StatusCode_Parse(
    const ::std::string& name, UdsInterfaceResponse_StatusCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UdsInterfaceResponse_StatusCode>(
    UdsInterfaceResponse_StatusCode_descriptor(), name, value);
}
enum UdsInterfaceStatus_State {
  UdsInterfaceStatus_State_UNKNOWN = 21,
  UdsInterfaceStatus_State_FREE = 0,
  UdsInterfaceStatus_State_READY = 1,
  UdsInterfaceStatus_State_BUSY = 2,
  UdsInterfaceStatus_State_TIMEOUT = 3,
  UdsInterfaceStatus_State_PROCESSING = 4
};
bool UdsInterfaceStatus_State_IsValid(int value);
const UdsInterfaceStatus_State UdsInterfaceStatus_State_State_MIN = UdsInterfaceStatus_State_FREE;
const UdsInterfaceStatus_State UdsInterfaceStatus_State_State_MAX = UdsInterfaceStatus_State_UNKNOWN;
const int UdsInterfaceStatus_State_State_ARRAYSIZE = UdsInterfaceStatus_State_State_MAX + 1;

const ::google::protobuf::EnumDescriptor* UdsInterfaceStatus_State_descriptor();
inline const ::std::string& UdsInterfaceStatus_State_Name(UdsInterfaceStatus_State value) {
  return ::google::protobuf::internal::NameOfEnum(
    UdsInterfaceStatus_State_descriptor(), value);
}
inline bool UdsInterfaceStatus_State_Parse(
    const ::std::string& name, UdsInterfaceStatus_State* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UdsInterfaceStatus_State>(
    UdsInterfaceStatus_State_descriptor(), name, value);
}
// ===================================================================

class UdsInterface : public ::google::protobuf::Message {
 public:
  UdsInterface();
  virtual ~UdsInterface();

  UdsInterface(const UdsInterface& from);

  inline UdsInterface& operator=(const UdsInterface& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UdsInterface& default_instance();

  void Swap(UdsInterface* other);

  // implements Message ----------------------------------------------

  UdsInterface* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UdsInterface& from);
  void MergeFrom(const UdsInterface& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef UdsInterface_TransportProtocol TransportProtocol;
  static const TransportProtocol TP_UNKNOWN = UdsInterface_TransportProtocol_TP_UNKNOWN;
  static const TransportProtocol TP_ISO = UdsInterface_TransportProtocol_TP_ISO;
  static inline bool TransportProtocol_IsValid(int value) {
    return UdsInterface_TransportProtocol_IsValid(value);
  }
  static const TransportProtocol TransportProtocol_MIN =
    UdsInterface_TransportProtocol_TransportProtocol_MIN;
  static const TransportProtocol TransportProtocol_MAX =
    UdsInterface_TransportProtocol_TransportProtocol_MAX;
  static const int TransportProtocol_ARRAYSIZE =
    UdsInterface_TransportProtocol_TransportProtocol_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  TransportProtocol_descriptor() {
    return UdsInterface_TransportProtocol_descriptor();
  }
  static inline const ::std::string& TransportProtocol_Name(TransportProtocol value) {
    return UdsInterface_TransportProtocol_Name(value);
  }
  static inline bool TransportProtocol_Parse(const ::std::string& name,
      TransportProtocol* value) {
    return UdsInterface_TransportProtocol_Parse(name, value);
  }

  typedef UdsInterface_PhysicalInterface PhysicalInterface;
  static const PhysicalInterface IF_UNKNOWN = UdsInterface_PhysicalInterface_IF_UNKNOWN;
  static const PhysicalInterface IF_CAN1 = UdsInterface_PhysicalInterface_IF_CAN1;
  static const PhysicalInterface IF_CAN2 = UdsInterface_PhysicalInterface_IF_CAN2;
  static inline bool PhysicalInterface_IsValid(int value) {
    return UdsInterface_PhysicalInterface_IsValid(value);
  }
  static const PhysicalInterface PhysicalInterface_MIN =
    UdsInterface_PhysicalInterface_PhysicalInterface_MIN;
  static const PhysicalInterface PhysicalInterface_MAX =
    UdsInterface_PhysicalInterface_PhysicalInterface_MAX;
  static const int PhysicalInterface_ARRAYSIZE =
    UdsInterface_PhysicalInterface_PhysicalInterface_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  PhysicalInterface_descriptor() {
    return UdsInterface_PhysicalInterface_descriptor();
  }
  static inline const ::std::string& PhysicalInterface_Name(PhysicalInterface value) {
    return UdsInterface_PhysicalInterface_Name(value);
  }
  static inline bool PhysicalInterface_Parse(const ::std::string& name,
      PhysicalInterface* value) {
    return UdsInterface_PhysicalInterface_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .ecu.lapi.pb.UdsInterface.TransportProtocol protocol = 1;
  inline bool has_protocol() const;
  inline void clear_protocol();
  static const int kProtocolFieldNumber = 1;
  inline ::ecu::lapi::pb::UdsInterface_TransportProtocol protocol() const;
  inline void set_protocol(::ecu::lapi::pb::UdsInterface_TransportProtocol value);

  // optional .ecu.lapi.pb.UdsInterface.PhysicalInterface phyif = 2;
  inline bool has_phyif() const;
  inline void clear_phyif();
  static const int kPhyifFieldNumber = 2;
  inline ::ecu::lapi::pb::UdsInterface_PhysicalInterface phyif() const;
  inline void set_phyif(::ecu::lapi::pb::UdsInterface_PhysicalInterface value);

  // optional uint32 target = 3;
  inline bool has_target() const;
  inline void clear_target();
  static const int kTargetFieldNumber = 3;
  inline ::google::protobuf::uint32 target() const;
  inline void set_target(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ecu.lapi.pb.UdsInterface)
 private:
  inline void set_has_protocol();
  inline void clear_has_protocol();
  inline void set_has_phyif();
  inline void clear_has_phyif();
  inline void set_has_target();
  inline void clear_has_target();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int protocol_;
  int phyif_;
  ::google::protobuf::uint32 target_;
  friend void  protobuf_AddDesc_uds_2eproto();
  friend void protobuf_AssignDesc_uds_2eproto();
  friend void protobuf_ShutdownFile_uds_2eproto();

  void InitAsDefaultInstance();
  static UdsInterface* default_instance_;
};
// -------------------------------------------------------------------

class UdsInterfaceAllocation : public ::google::protobuf::Message {
 public:
  UdsInterfaceAllocation();
  virtual ~UdsInterfaceAllocation();

  UdsInterfaceAllocation(const UdsInterfaceAllocation& from);

  inline UdsInterfaceAllocation& operator=(const UdsInterfaceAllocation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UdsInterfaceAllocation& default_instance();

  void Swap(UdsInterfaceAllocation* other);

  // implements Message ----------------------------------------------

  UdsInterfaceAllocation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UdsInterfaceAllocation& from);
  void MergeFrom(const UdsInterfaceAllocation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string client_name = 1;
  inline bool has_client_name() const;
  inline void clear_client_name();
  static const int kClientNameFieldNumber = 1;
  inline const ::std::string& client_name() const;
  inline void set_client_name(const ::std::string& value);
  inline void set_client_name(const char* value);
  inline void set_client_name(const char* value, size_t size);
  inline ::std::string* mutable_client_name();
  inline ::std::string* release_client_name();
  inline void set_allocated_client_name(::std::string* client_name);

  // @@protoc_insertion_point(class_scope:ecu.lapi.pb.UdsInterfaceAllocation)
 private:
  inline void set_has_client_name();
  inline void clear_has_client_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* client_name_;
  friend void  protobuf_AddDesc_uds_2eproto();
  friend void protobuf_AssignDesc_uds_2eproto();
  friend void protobuf_ShutdownFile_uds_2eproto();

  void InitAsDefaultInstance();
  static UdsInterfaceAllocation* default_instance_;
};
// -------------------------------------------------------------------

class UdsInterfaceRequest : public ::google::protobuf::Message {
 public:
  UdsInterfaceRequest();
  virtual ~UdsInterfaceRequest();

  UdsInterfaceRequest(const UdsInterfaceRequest& from);

  inline UdsInterfaceRequest& operator=(const UdsInterfaceRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UdsInterfaceRequest& default_instance();

  void Swap(UdsInterfaceRequest* other);

  // implements Message ----------------------------------------------

  UdsInterfaceRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UdsInterfaceRequest& from);
  void MergeFrom(const UdsInterfaceRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef UdsInterfaceRequest_FlowStatus FlowStatus;
  static const FlowStatus FS_CTS = UdsInterfaceRequest_FlowStatus_FS_CTS;
  static const FlowStatus FS_WAIT = UdsInterfaceRequest_FlowStatus_FS_WAIT;
  static const FlowStatus FS_SUPPRESS = UdsInterfaceRequest_FlowStatus_FS_SUPPRESS;
  static const FlowStatus FS_OVERFLOW = UdsInterfaceRequest_FlowStatus_FS_OVERFLOW;
  static inline bool FlowStatus_IsValid(int value) {
    return UdsInterfaceRequest_FlowStatus_IsValid(value);
  }
  static const FlowStatus FlowStatus_MIN =
    UdsInterfaceRequest_FlowStatus_FlowStatus_MIN;
  static const FlowStatus FlowStatus_MAX =
    UdsInterfaceRequest_FlowStatus_FlowStatus_MAX;
  static const int FlowStatus_ARRAYSIZE =
    UdsInterfaceRequest_FlowStatus_FlowStatus_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  FlowStatus_descriptor() {
    return UdsInterfaceRequest_FlowStatus_descriptor();
  }
  static inline const ::std::string& FlowStatus_Name(FlowStatus value) {
    return UdsInterfaceRequest_FlowStatus_Name(value);
  }
  static inline bool FlowStatus_Parse(const ::std::string& name,
      FlowStatus* value) {
    return UdsInterfaceRequest_FlowStatus_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string client_name = 1;
  inline bool has_client_name() const;
  inline void clear_client_name();
  static const int kClientNameFieldNumber = 1;
  inline const ::std::string& client_name() const;
  inline void set_client_name(const ::std::string& value);
  inline void set_client_name(const char* value);
  inline void set_client_name(const char* value, size_t size);
  inline ::std::string* mutable_client_name();
  inline ::std::string* release_client_name();
  inline void set_allocated_client_name(::std::string* client_name);

  // optional bytes data = 2;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 2;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // optional uint32 source = 5 [default = 255];
  inline bool has_source() const;
  inline void clear_source();
  static const int kSourceFieldNumber = 5;
  inline ::google::protobuf::uint32 source() const;
  inline void set_source(::google::protobuf::uint32 value);

  // optional uint32 st_min = 3 [default = 255];
  inline bool has_st_min() const;
  inline void clear_st_min();
  static const int kStMinFieldNumber = 3;
  inline ::google::protobuf::uint32 st_min() const;
  inline void set_st_min(::google::protobuf::uint32 value);

  // optional uint32 st_min_res = 6 [default = 255];
  inline bool has_st_min_res() const;
  inline void clear_st_min_res();
  static const int kStMinResFieldNumber = 6;
  inline ::google::protobuf::uint32 st_min_res() const;
  inline void set_st_min_res(::google::protobuf::uint32 value);

  // optional uint32 block_size_res = 7 [default = 256];
  inline bool has_block_size_res() const;
  inline void clear_block_size_res();
  static const int kBlockSizeResFieldNumber = 7;
  inline ::google::protobuf::uint32 block_size_res() const;
  inline void set_block_size_res(::google::protobuf::uint32 value);

  // optional .ecu.lapi.pb.UdsInterfaceRequest.FlowStatus flow_status_res = 8 [default = FS_CTS];
  inline bool has_flow_status_res() const;
  inline void clear_flow_status_res();
  static const int kFlowStatusResFieldNumber = 8;
  inline ::ecu::lapi::pb::UdsInterfaceRequest_FlowStatus flow_status_res() const;
  inline void set_flow_status_res(::ecu::lapi::pb::UdsInterfaceRequest_FlowStatus value);

  // optional uint32 timeout_ms = 4 [default = 150000];
  inline bool has_timeout_ms() const;
  inline void clear_timeout_ms();
  static const int kTimeoutMsFieldNumber = 4;
  inline ::google::protobuf::uint32 timeout_ms() const;
  inline void set_timeout_ms(::google::protobuf::uint32 value);

  // optional uint32 max_len_resp = 9 [default = 4096];
  inline bool has_max_len_resp() const;
  inline void clear_max_len_resp();
  static const int kMaxLenRespFieldNumber = 9;
  inline ::google::protobuf::uint32 max_len_resp() const;
  inline void set_max_len_resp(::google::protobuf::uint32 value);

  // optional uint32 p2_timeout_ms = 10 [default = 150];
  inline bool has_p2_timeout_ms() const;
  inline void clear_p2_timeout_ms();
  static const int kP2TimeoutMsFieldNumber = 10;
  inline ::google::protobuf::uint32 p2_timeout_ms() const;
  inline void set_p2_timeout_ms(::google::protobuf::uint32 value);

  // optional uint32 p2star_timeout_ms = 11 [default = 5000];
  inline bool has_p2star_timeout_ms() const;
  inline void clear_p2star_timeout_ms();
  static const int kP2StarTimeoutMsFieldNumber = 11;
  inline ::google::protobuf::uint32 p2star_timeout_ms() const;
  inline void set_p2star_timeout_ms(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ecu.lapi.pb.UdsInterfaceRequest)
 private:
  inline void set_has_client_name();
  inline void clear_has_client_name();
  inline void set_has_data();
  inline void clear_has_data();
  inline void set_has_source();
  inline void clear_has_source();
  inline void set_has_st_min();
  inline void clear_has_st_min();
  inline void set_has_st_min_res();
  inline void clear_has_st_min_res();
  inline void set_has_block_size_res();
  inline void clear_has_block_size_res();
  inline void set_has_flow_status_res();
  inline void clear_has_flow_status_res();
  inline void set_has_timeout_ms();
  inline void clear_has_timeout_ms();
  inline void set_has_max_len_resp();
  inline void clear_has_max_len_resp();
  inline void set_has_p2_timeout_ms();
  inline void clear_has_p2_timeout_ms();
  inline void set_has_p2star_timeout_ms();
  inline void clear_has_p2star_timeout_ms();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* client_name_;
  ::std::string* data_;
  ::google::protobuf::uint32 source_;
  ::google::protobuf::uint32 st_min_;
  ::google::protobuf::uint32 st_min_res_;
  ::google::protobuf::uint32 block_size_res_;
  int flow_status_res_;
  ::google::protobuf::uint32 timeout_ms_;
  ::google::protobuf::uint32 max_len_resp_;
  ::google::protobuf::uint32 p2_timeout_ms_;
  ::google::protobuf::uint32 p2star_timeout_ms_;
  friend void  protobuf_AddDesc_uds_2eproto();
  friend void protobuf_AssignDesc_uds_2eproto();
  friend void protobuf_ShutdownFile_uds_2eproto();

  void InitAsDefaultInstance();
  static UdsInterfaceRequest* default_instance_;
};
// -------------------------------------------------------------------

class UdsInterfaceResponse : public ::google::protobuf::Message {
 public:
  UdsInterfaceResponse();
  virtual ~UdsInterfaceResponse();

  UdsInterfaceResponse(const UdsInterfaceResponse& from);

  inline UdsInterfaceResponse& operator=(const UdsInterfaceResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UdsInterfaceResponse& default_instance();

  void Swap(UdsInterfaceResponse* other);

  // implements Message ----------------------------------------------

  UdsInterfaceResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UdsInterfaceResponse& from);
  void MergeFrom(const UdsInterfaceResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef UdsInterfaceResponse_StatusCode StatusCode;
  static const StatusCode UNKNOWN_ERROR = UdsInterfaceResponse_StatusCode_UNKNOWN_ERROR;
  static const StatusCode OK = UdsInterfaceResponse_StatusCode_OK;
  static const StatusCode TIMEOUT = UdsInterfaceResponse_StatusCode_TIMEOUT;
  static const StatusCode BUSY = UdsInterfaceResponse_StatusCode_BUSY;
  static const StatusCode INTERRUPTED = UdsInterfaceResponse_StatusCode_INTERRUPTED;
  static const StatusCode LENGTH_ERROR = UdsInterfaceResponse_StatusCode_LENGTH_ERROR;
  static const StatusCode OVERFLOWED = UdsInterfaceResponse_StatusCode_OVERFLOWED;
  static const StatusCode REJECTED = UdsInterfaceResponse_StatusCode_REJECTED;
  static const StatusCode RT_CAN_ERROR = UdsInterfaceResponse_StatusCode_RT_CAN_ERROR;
  static const StatusCode RT_POWEROFF = UdsInterfaceResponse_StatusCode_RT_POWEROFF;
  static const StatusCode RT_TIMEOUT = UdsInterfaceResponse_StatusCode_RT_TIMEOUT;
  static const StatusCode RT_P2_TIMEOUT = UdsInterfaceResponse_StatusCode_RT_P2_TIMEOUT;
  static const StatusCode RT_P2STAR_TIMEOUT = UdsInterfaceResponse_StatusCode_RT_P2STAR_TIMEOUT;
  static const StatusCode LINUX_IF_NOT_ALLOC = UdsInterfaceResponse_StatusCode_LINUX_IF_NOT_ALLOC;
  static const StatusCode LINUX_TX_ERROR = UdsInterfaceResponse_StatusCode_LINUX_TX_ERROR;
  static const StatusCode LINUX_PB_SER_ERROR = UdsInterfaceResponse_StatusCode_LINUX_PB_SER_ERROR;
  static const StatusCode LINUX_UNKNOWN_ERROR = UdsInterfaceResponse_StatusCode_LINUX_UNKNOWN_ERROR;
  static inline bool StatusCode_IsValid(int value) {
    return UdsInterfaceResponse_StatusCode_IsValid(value);
  }
  static const StatusCode StatusCode_MIN =
    UdsInterfaceResponse_StatusCode_StatusCode_MIN;
  static const StatusCode StatusCode_MAX =
    UdsInterfaceResponse_StatusCode_StatusCode_MAX;
  static const int StatusCode_ARRAYSIZE =
    UdsInterfaceResponse_StatusCode_StatusCode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  StatusCode_descriptor() {
    return UdsInterfaceResponse_StatusCode_descriptor();
  }
  static inline const ::std::string& StatusCode_Name(StatusCode value) {
    return UdsInterfaceResponse_StatusCode_Name(value);
  }
  static inline bool StatusCode_Parse(const ::std::string& name,
      StatusCode* value) {
    return UdsInterfaceResponse_StatusCode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .ecu.lapi.pb.UdsInterfaceResponse.StatusCode status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::ecu::lapi::pb::UdsInterfaceResponse_StatusCode status() const;
  inline void set_status(::ecu::lapi::pb::UdsInterfaceResponse_StatusCode value);

  // optional uint64 trans_id = 2;
  inline bool has_trans_id() const;
  inline void clear_trans_id();
  static const int kTransIdFieldNumber = 2;
  inline ::google::protobuf::uint64 trans_id() const;
  inline void set_trans_id(::google::protobuf::uint64 value);

  // optional uint32 source = 3;
  inline bool has_source() const;
  inline void clear_source();
  static const int kSourceFieldNumber = 3;
  inline ::google::protobuf::uint32 source() const;
  inline void set_source(::google::protobuf::uint32 value);

  // optional bytes data = 4;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 4;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:ecu.lapi.pb.UdsInterfaceResponse)
 private:
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_trans_id();
  inline void clear_has_trans_id();
  inline void set_has_source();
  inline void clear_has_source();
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 trans_id_;
  int status_;
  ::google::protobuf::uint32 source_;
  ::std::string* data_;
  friend void  protobuf_AddDesc_uds_2eproto();
  friend void protobuf_AssignDesc_uds_2eproto();
  friend void protobuf_ShutdownFile_uds_2eproto();

  void InitAsDefaultInstance();
  static UdsInterfaceResponse* default_instance_;
};
// -------------------------------------------------------------------

class UdsInterfaceStatus : public ::google::protobuf::Message {
 public:
  UdsInterfaceStatus();
  virtual ~UdsInterfaceStatus();

  UdsInterfaceStatus(const UdsInterfaceStatus& from);

  inline UdsInterfaceStatus& operator=(const UdsInterfaceStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UdsInterfaceStatus& default_instance();

  void Swap(UdsInterfaceStatus* other);

  // implements Message ----------------------------------------------

  UdsInterfaceStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UdsInterfaceStatus& from);
  void MergeFrom(const UdsInterfaceStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef UdsInterfaceStatus_State State;
  static const State UNKNOWN = UdsInterfaceStatus_State_UNKNOWN;
  static const State FREE = UdsInterfaceStatus_State_FREE;
  static const State READY = UdsInterfaceStatus_State_READY;
  static const State BUSY = UdsInterfaceStatus_State_BUSY;
  static const State TIMEOUT = UdsInterfaceStatus_State_TIMEOUT;
  static const State PROCESSING = UdsInterfaceStatus_State_PROCESSING;
  static inline bool State_IsValid(int value) {
    return UdsInterfaceStatus_State_IsValid(value);
  }
  static const State State_MIN =
    UdsInterfaceStatus_State_State_MIN;
  static const State State_MAX =
    UdsInterfaceStatus_State_State_MAX;
  static const int State_ARRAYSIZE =
    UdsInterfaceStatus_State_State_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  State_descriptor() {
    return UdsInterfaceStatus_State_descriptor();
  }
  static inline const ::std::string& State_Name(State value) {
    return UdsInterfaceStatus_State_Name(value);
  }
  static inline bool State_Parse(const ::std::string& name,
      State* value) {
    return UdsInterfaceStatus_State_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .ecu.lapi.pb.UdsInterfaceStatus.State state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline ::ecu::lapi::pb::UdsInterfaceStatus_State state() const;
  inline void set_state(::ecu::lapi::pb::UdsInterfaceStatus_State value);

  // optional string used_by = 2;
  inline bool has_used_by() const;
  inline void clear_used_by();
  static const int kUsedByFieldNumber = 2;
  inline const ::std::string& used_by() const;
  inline void set_used_by(const ::std::string& value);
  inline void set_used_by(const char* value);
  inline void set_used_by(const char* value, size_t size);
  inline ::std::string* mutable_used_by();
  inline ::std::string* release_used_by();
  inline void set_allocated_used_by(::std::string* used_by);

  // @@protoc_insertion_point(class_scope:ecu.lapi.pb.UdsInterfaceStatus)
 private:
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_used_by();
  inline void clear_has_used_by();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* used_by_;
  int state_;
  friend void  protobuf_AddDesc_uds_2eproto();
  friend void protobuf_AssignDesc_uds_2eproto();
  friend void protobuf_ShutdownFile_uds_2eproto();

  void InitAsDefaultInstance();
  static UdsInterfaceStatus* default_instance_;
};
// -------------------------------------------------------------------

class UdsIfMessage : public ::google::protobuf::Message {
 public:
  UdsIfMessage();
  virtual ~UdsIfMessage();

  UdsIfMessage(const UdsIfMessage& from);

  inline UdsIfMessage& operator=(const UdsIfMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UdsIfMessage& default_instance();

  void Swap(UdsIfMessage* other);

  // implements Message ----------------------------------------------

  UdsIfMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UdsIfMessage& from);
  void MergeFrom(const UdsIfMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ecu.lapi.pb.UdsInterface interface = 1;
  inline bool has_interface() const;
  inline void clear_interface();
  static const int kInterfaceFieldNumber = 1;
  inline const ::ecu::lapi::pb::UdsInterface& interface() const;
  inline ::ecu::lapi::pb::UdsInterface* mutable_interface();
  inline ::ecu::lapi::pb::UdsInterface* release_interface();
  inline void set_allocated_interface(::ecu::lapi::pb::UdsInterface* interface);

  // optional .ecu.lapi.pb.UdsInterfaceAllocation allocation = 2;
  inline bool has_allocation() const;
  inline void clear_allocation();
  static const int kAllocationFieldNumber = 2;
  inline const ::ecu::lapi::pb::UdsInterfaceAllocation& allocation() const;
  inline ::ecu::lapi::pb::UdsInterfaceAllocation* mutable_allocation();
  inline ::ecu::lapi::pb::UdsInterfaceAllocation* release_allocation();
  inline void set_allocated_allocation(::ecu::lapi::pb::UdsInterfaceAllocation* allocation);

  // optional .ecu.lapi.pb.UdsInterfaceRequest request = 3;
  inline bool has_request() const;
  inline void clear_request();
  static const int kRequestFieldNumber = 3;
  inline const ::ecu::lapi::pb::UdsInterfaceRequest& request() const;
  inline ::ecu::lapi::pb::UdsInterfaceRequest* mutable_request();
  inline ::ecu::lapi::pb::UdsInterfaceRequest* release_request();
  inline void set_allocated_request(::ecu::lapi::pb::UdsInterfaceRequest* request);

  // optional .ecu.lapi.pb.UdsInterfaceResponse response = 4;
  inline bool has_response() const;
  inline void clear_response();
  static const int kResponseFieldNumber = 4;
  inline const ::ecu::lapi::pb::UdsInterfaceResponse& response() const;
  inline ::ecu::lapi::pb::UdsInterfaceResponse* mutable_response();
  inline ::ecu::lapi::pb::UdsInterfaceResponse* release_response();
  inline void set_allocated_response(::ecu::lapi::pb::UdsInterfaceResponse* response);

  // optional .ecu.lapi.pb.UdsInterfaceStatus status = 5;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 5;
  inline const ::ecu::lapi::pb::UdsInterfaceStatus& status() const;
  inline ::ecu::lapi::pb::UdsInterfaceStatus* mutable_status();
  inline ::ecu::lapi::pb::UdsInterfaceStatus* release_status();
  inline void set_allocated_status(::ecu::lapi::pb::UdsInterfaceStatus* status);

  // @@protoc_insertion_point(class_scope:ecu.lapi.pb.UdsIfMessage)
 private:
  inline void set_has_interface();
  inline void clear_has_interface();
  inline void set_has_allocation();
  inline void clear_has_allocation();
  inline void set_has_request();
  inline void clear_has_request();
  inline void set_has_response();
  inline void clear_has_response();
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::ecu::lapi::pb::UdsInterface* interface_;
  ::ecu::lapi::pb::UdsInterfaceAllocation* allocation_;
  ::ecu::lapi::pb::UdsInterfaceRequest* request_;
  ::ecu::lapi::pb::UdsInterfaceResponse* response_;
  ::ecu::lapi::pb::UdsInterfaceStatus* status_;
  friend void  protobuf_AddDesc_uds_2eproto();
  friend void protobuf_AssignDesc_uds_2eproto();
  friend void protobuf_ShutdownFile_uds_2eproto();

  void InitAsDefaultInstance();
  static UdsIfMessage* default_instance_;
};
// ===================================================================


// ===================================================================

// UdsInterface

// optional .ecu.lapi.pb.UdsInterface.TransportProtocol protocol = 1;
inline bool UdsInterface::has_protocol() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UdsInterface::set_has_protocol() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UdsInterface::clear_has_protocol() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UdsInterface::clear_protocol() {
  protocol_ = 10;
  clear_has_protocol();
}
inline ::ecu::lapi::pb::UdsInterface_TransportProtocol UdsInterface::protocol() const {
  // @@protoc_insertion_point(field_get:ecu.lapi.pb.UdsInterface.protocol)
  return static_cast< ::ecu::lapi::pb::UdsInterface_TransportProtocol >(protocol_);
}
inline void UdsInterface::set_protocol(::ecu::lapi::pb::UdsInterface_TransportProtocol value) {
  assert(::ecu::lapi::pb::UdsInterface_TransportProtocol_IsValid(value));
  set_has_protocol();
  protocol_ = value;
  // @@protoc_insertion_point(field_set:ecu.lapi.pb.UdsInterface.protocol)
}

// optional .ecu.lapi.pb.UdsInterface.PhysicalInterface phyif = 2;
inline bool UdsInterface::has_phyif() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UdsInterface::set_has_phyif() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UdsInterface::clear_has_phyif() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UdsInterface::clear_phyif() {
  phyif_ = 10;
  clear_has_phyif();
}
inline ::ecu::lapi::pb::UdsInterface_PhysicalInterface UdsInterface::phyif() const {
  // @@protoc_insertion_point(field_get:ecu.lapi.pb.UdsInterface.phyif)
  return static_cast< ::ecu::lapi::pb::UdsInterface_PhysicalInterface >(phyif_);
}
inline void UdsInterface::set_phyif(::ecu::lapi::pb::UdsInterface_PhysicalInterface value) {
  assert(::ecu::lapi::pb::UdsInterface_PhysicalInterface_IsValid(value));
  set_has_phyif();
  phyif_ = value;
  // @@protoc_insertion_point(field_set:ecu.lapi.pb.UdsInterface.phyif)
}

// optional uint32 target = 3;
inline bool UdsInterface::has_target() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UdsInterface::set_has_target() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UdsInterface::clear_has_target() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UdsInterface::clear_target() {
  target_ = 0u;
  clear_has_target();
}
inline ::google::protobuf::uint32 UdsInterface::target() const {
  // @@protoc_insertion_point(field_get:ecu.lapi.pb.UdsInterface.target)
  return target_;
}
inline void UdsInterface::set_target(::google::protobuf::uint32 value) {
  set_has_target();
  target_ = value;
  // @@protoc_insertion_point(field_set:ecu.lapi.pb.UdsInterface.target)
}

// -------------------------------------------------------------------

// UdsInterfaceAllocation

// optional string client_name = 1;
inline bool UdsInterfaceAllocation::has_client_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UdsInterfaceAllocation::set_has_client_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UdsInterfaceAllocation::clear_has_client_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UdsInterfaceAllocation::clear_client_name() {
  if (client_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_name_->clear();
  }
  clear_has_client_name();
}
inline const ::std::string& UdsInterfaceAllocation::client_name() const {
  // @@protoc_insertion_point(field_get:ecu.lapi.pb.UdsInterfaceAllocation.client_name)
  return *client_name_;
}
inline void UdsInterfaceAllocation::set_client_name(const ::std::string& value) {
  set_has_client_name();
  if (client_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_name_ = new ::std::string;
  }
  client_name_->assign(value);
  // @@protoc_insertion_point(field_set:ecu.lapi.pb.UdsInterfaceAllocation.client_name)
}
inline void UdsInterfaceAllocation::set_client_name(const char* value) {
  set_has_client_name();
  if (client_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_name_ = new ::std::string;
  }
  client_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:ecu.lapi.pb.UdsInterfaceAllocation.client_name)
}
inline void UdsInterfaceAllocation::set_client_name(const char* value, size_t size) {
  set_has_client_name();
  if (client_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_name_ = new ::std::string;
  }
  client_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ecu.lapi.pb.UdsInterfaceAllocation.client_name)
}
inline ::std::string* UdsInterfaceAllocation::mutable_client_name() {
  set_has_client_name();
  if (client_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ecu.lapi.pb.UdsInterfaceAllocation.client_name)
  return client_name_;
}
inline ::std::string* UdsInterfaceAllocation::release_client_name() {
  clear_has_client_name();
  if (client_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = client_name_;
    client_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UdsInterfaceAllocation::set_allocated_client_name(::std::string* client_name) {
  if (client_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete client_name_;
  }
  if (client_name) {
    set_has_client_name();
    client_name_ = client_name;
  } else {
    clear_has_client_name();
    client_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ecu.lapi.pb.UdsInterfaceAllocation.client_name)
}

// -------------------------------------------------------------------

// UdsInterfaceRequest

// optional string client_name = 1;
inline bool UdsInterfaceRequest::has_client_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UdsInterfaceRequest::set_has_client_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UdsInterfaceRequest::clear_has_client_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UdsInterfaceRequest::clear_client_name() {
  if (client_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_name_->clear();
  }
  clear_has_client_name();
}
inline const ::std::string& UdsInterfaceRequest::client_name() const {
  // @@protoc_insertion_point(field_get:ecu.lapi.pb.UdsInterfaceRequest.client_name)
  return *client_name_;
}
inline void UdsInterfaceRequest::set_client_name(const ::std::string& value) {
  set_has_client_name();
  if (client_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_name_ = new ::std::string;
  }
  client_name_->assign(value);
  // @@protoc_insertion_point(field_set:ecu.lapi.pb.UdsInterfaceRequest.client_name)
}
inline void UdsInterfaceRequest::set_client_name(const char* value) {
  set_has_client_name();
  if (client_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_name_ = new ::std::string;
  }
  client_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:ecu.lapi.pb.UdsInterfaceRequest.client_name)
}
inline void UdsInterfaceRequest::set_client_name(const char* value, size_t size) {
  set_has_client_name();
  if (client_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_name_ = new ::std::string;
  }
  client_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ecu.lapi.pb.UdsInterfaceRequest.client_name)
}
inline ::std::string* UdsInterfaceRequest::mutable_client_name() {
  set_has_client_name();
  if (client_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ecu.lapi.pb.UdsInterfaceRequest.client_name)
  return client_name_;
}
inline ::std::string* UdsInterfaceRequest::release_client_name() {
  clear_has_client_name();
  if (client_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = client_name_;
    client_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UdsInterfaceRequest::set_allocated_client_name(::std::string* client_name) {
  if (client_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete client_name_;
  }
  if (client_name) {
    set_has_client_name();
    client_name_ = client_name;
  } else {
    clear_has_client_name();
    client_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ecu.lapi.pb.UdsInterfaceRequest.client_name)
}

// optional bytes data = 2;
inline bool UdsInterfaceRequest::has_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UdsInterfaceRequest::set_has_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UdsInterfaceRequest::clear_has_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UdsInterfaceRequest::clear_data() {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& UdsInterfaceRequest::data() const {
  // @@protoc_insertion_point(field_get:ecu.lapi.pb.UdsInterfaceRequest.data)
  return *data_;
}
inline void UdsInterfaceRequest::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set:ecu.lapi.pb.UdsInterfaceRequest.data)
}
inline void UdsInterfaceRequest::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set_char:ecu.lapi.pb.UdsInterfaceRequest.data)
}
inline void UdsInterfaceRequest::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ecu.lapi.pb.UdsInterfaceRequest.data)
}
inline ::std::string* UdsInterfaceRequest::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ecu.lapi.pb.UdsInterfaceRequest.data)
  return data_;
}
inline ::std::string* UdsInterfaceRequest::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UdsInterfaceRequest::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ecu.lapi.pb.UdsInterfaceRequest.data)
}

// optional uint32 source = 5 [default = 255];
inline bool UdsInterfaceRequest::has_source() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UdsInterfaceRequest::set_has_source() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UdsInterfaceRequest::clear_has_source() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UdsInterfaceRequest::clear_source() {
  source_ = 255u;
  clear_has_source();
}
inline ::google::protobuf::uint32 UdsInterfaceRequest::source() const {
  // @@protoc_insertion_point(field_get:ecu.lapi.pb.UdsInterfaceRequest.source)
  return source_;
}
inline void UdsInterfaceRequest::set_source(::google::protobuf::uint32 value) {
  set_has_source();
  source_ = value;
  // @@protoc_insertion_point(field_set:ecu.lapi.pb.UdsInterfaceRequest.source)
}

// optional uint32 st_min = 3 [default = 255];
inline bool UdsInterfaceRequest::has_st_min() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UdsInterfaceRequest::set_has_st_min() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UdsInterfaceRequest::clear_has_st_min() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UdsInterfaceRequest::clear_st_min() {
  st_min_ = 255u;
  clear_has_st_min();
}
inline ::google::protobuf::uint32 UdsInterfaceRequest::st_min() const {
  // @@protoc_insertion_point(field_get:ecu.lapi.pb.UdsInterfaceRequest.st_min)
  return st_min_;
}
inline void UdsInterfaceRequest::set_st_min(::google::protobuf::uint32 value) {
  set_has_st_min();
  st_min_ = value;
  // @@protoc_insertion_point(field_set:ecu.lapi.pb.UdsInterfaceRequest.st_min)
}

// optional uint32 st_min_res = 6 [default = 255];
inline bool UdsInterfaceRequest::has_st_min_res() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UdsInterfaceRequest::set_has_st_min_res() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UdsInterfaceRequest::clear_has_st_min_res() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UdsInterfaceRequest::clear_st_min_res() {
  st_min_res_ = 255u;
  clear_has_st_min_res();
}
inline ::google::protobuf::uint32 UdsInterfaceRequest::st_min_res() const {
  // @@protoc_insertion_point(field_get:ecu.lapi.pb.UdsInterfaceRequest.st_min_res)
  return st_min_res_;
}
inline void UdsInterfaceRequest::set_st_min_res(::google::protobuf::uint32 value) {
  set_has_st_min_res();
  st_min_res_ = value;
  // @@protoc_insertion_point(field_set:ecu.lapi.pb.UdsInterfaceRequest.st_min_res)
}

// optional uint32 block_size_res = 7 [default = 256];
inline bool UdsInterfaceRequest::has_block_size_res() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UdsInterfaceRequest::set_has_block_size_res() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UdsInterfaceRequest::clear_has_block_size_res() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UdsInterfaceRequest::clear_block_size_res() {
  block_size_res_ = 256u;
  clear_has_block_size_res();
}
inline ::google::protobuf::uint32 UdsInterfaceRequest::block_size_res() const {
  // @@protoc_insertion_point(field_get:ecu.lapi.pb.UdsInterfaceRequest.block_size_res)
  return block_size_res_;
}
inline void UdsInterfaceRequest::set_block_size_res(::google::protobuf::uint32 value) {
  set_has_block_size_res();
  block_size_res_ = value;
  // @@protoc_insertion_point(field_set:ecu.lapi.pb.UdsInterfaceRequest.block_size_res)
}

// optional .ecu.lapi.pb.UdsInterfaceRequest.FlowStatus flow_status_res = 8 [default = FS_CTS];
inline bool UdsInterfaceRequest::has_flow_status_res() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UdsInterfaceRequest::set_has_flow_status_res() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UdsInterfaceRequest::clear_has_flow_status_res() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UdsInterfaceRequest::clear_flow_status_res() {
  flow_status_res_ = 0;
  clear_has_flow_status_res();
}
inline ::ecu::lapi::pb::UdsInterfaceRequest_FlowStatus UdsInterfaceRequest::flow_status_res() const {
  // @@protoc_insertion_point(field_get:ecu.lapi.pb.UdsInterfaceRequest.flow_status_res)
  return static_cast< ::ecu::lapi::pb::UdsInterfaceRequest_FlowStatus >(flow_status_res_);
}
inline void UdsInterfaceRequest::set_flow_status_res(::ecu::lapi::pb::UdsInterfaceRequest_FlowStatus value) {
  assert(::ecu::lapi::pb::UdsInterfaceRequest_FlowStatus_IsValid(value));
  set_has_flow_status_res();
  flow_status_res_ = value;
  // @@protoc_insertion_point(field_set:ecu.lapi.pb.UdsInterfaceRequest.flow_status_res)
}

// optional uint32 timeout_ms = 4 [default = 150000];
inline bool UdsInterfaceRequest::has_timeout_ms() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void UdsInterfaceRequest::set_has_timeout_ms() {
  _has_bits_[0] |= 0x00000080u;
}
inline void UdsInterfaceRequest::clear_has_timeout_ms() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void UdsInterfaceRequest::clear_timeout_ms() {
  timeout_ms_ = 150000u;
  clear_has_timeout_ms();
}
inline ::google::protobuf::uint32 UdsInterfaceRequest::timeout_ms() const {
  // @@protoc_insertion_point(field_get:ecu.lapi.pb.UdsInterfaceRequest.timeout_ms)
  return timeout_ms_;
}
inline void UdsInterfaceRequest::set_timeout_ms(::google::protobuf::uint32 value) {
  set_has_timeout_ms();
  timeout_ms_ = value;
  // @@protoc_insertion_point(field_set:ecu.lapi.pb.UdsInterfaceRequest.timeout_ms)
}

// optional uint32 max_len_resp = 9 [default = 4096];
inline bool UdsInterfaceRequest::has_max_len_resp() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void UdsInterfaceRequest::set_has_max_len_resp() {
  _has_bits_[0] |= 0x00000100u;
}
inline void UdsInterfaceRequest::clear_has_max_len_resp() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void UdsInterfaceRequest::clear_max_len_resp() {
  max_len_resp_ = 4096u;
  clear_has_max_len_resp();
}
inline ::google::protobuf::uint32 UdsInterfaceRequest::max_len_resp() const {
  // @@protoc_insertion_point(field_get:ecu.lapi.pb.UdsInterfaceRequest.max_len_resp)
  return max_len_resp_;
}
inline void UdsInterfaceRequest::set_max_len_resp(::google::protobuf::uint32 value) {
  set_has_max_len_resp();
  max_len_resp_ = value;
  // @@protoc_insertion_point(field_set:ecu.lapi.pb.UdsInterfaceRequest.max_len_resp)
}

// optional uint32 p2_timeout_ms = 10 [default = 150];
inline bool UdsInterfaceRequest::has_p2_timeout_ms() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void UdsInterfaceRequest::set_has_p2_timeout_ms() {
  _has_bits_[0] |= 0x00000200u;
}
inline void UdsInterfaceRequest::clear_has_p2_timeout_ms() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void UdsInterfaceRequest::clear_p2_timeout_ms() {
  p2_timeout_ms_ = 150u;
  clear_has_p2_timeout_ms();
}
inline ::google::protobuf::uint32 UdsInterfaceRequest::p2_timeout_ms() const {
  // @@protoc_insertion_point(field_get:ecu.lapi.pb.UdsInterfaceRequest.p2_timeout_ms)
  return p2_timeout_ms_;
}
inline void UdsInterfaceRequest::set_p2_timeout_ms(::google::protobuf::uint32 value) {
  set_has_p2_timeout_ms();
  p2_timeout_ms_ = value;
  // @@protoc_insertion_point(field_set:ecu.lapi.pb.UdsInterfaceRequest.p2_timeout_ms)
}

// optional uint32 p2star_timeout_ms = 11 [default = 5000];
inline bool UdsInterfaceRequest::has_p2star_timeout_ms() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void UdsInterfaceRequest::set_has_p2star_timeout_ms() {
  _has_bits_[0] |= 0x00000400u;
}
inline void UdsInterfaceRequest::clear_has_p2star_timeout_ms() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void UdsInterfaceRequest::clear_p2star_timeout_ms() {
  p2star_timeout_ms_ = 5000u;
  clear_has_p2star_timeout_ms();
}
inline ::google::protobuf::uint32 UdsInterfaceRequest::p2star_timeout_ms() const {
  // @@protoc_insertion_point(field_get:ecu.lapi.pb.UdsInterfaceRequest.p2star_timeout_ms)
  return p2star_timeout_ms_;
}
inline void UdsInterfaceRequest::set_p2star_timeout_ms(::google::protobuf::uint32 value) {
  set_has_p2star_timeout_ms();
  p2star_timeout_ms_ = value;
  // @@protoc_insertion_point(field_set:ecu.lapi.pb.UdsInterfaceRequest.p2star_timeout_ms)
}

// -------------------------------------------------------------------

// UdsInterfaceResponse

// optional .ecu.lapi.pb.UdsInterfaceResponse.StatusCode status = 1;
inline bool UdsInterfaceResponse::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UdsInterfaceResponse::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UdsInterfaceResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UdsInterfaceResponse::clear_status() {
  status_ = 30;
  clear_has_status();
}
inline ::ecu::lapi::pb::UdsInterfaceResponse_StatusCode UdsInterfaceResponse::status() const {
  // @@protoc_insertion_point(field_get:ecu.lapi.pb.UdsInterfaceResponse.status)
  return static_cast< ::ecu::lapi::pb::UdsInterfaceResponse_StatusCode >(status_);
}
inline void UdsInterfaceResponse::set_status(::ecu::lapi::pb::UdsInterfaceResponse_StatusCode value) {
  assert(::ecu::lapi::pb::UdsInterfaceResponse_StatusCode_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:ecu.lapi.pb.UdsInterfaceResponse.status)
}

// optional uint64 trans_id = 2;
inline bool UdsInterfaceResponse::has_trans_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UdsInterfaceResponse::set_has_trans_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UdsInterfaceResponse::clear_has_trans_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UdsInterfaceResponse::clear_trans_id() {
  trans_id_ = GOOGLE_ULONGLONG(0);
  clear_has_trans_id();
}
inline ::google::protobuf::uint64 UdsInterfaceResponse::trans_id() const {
  // @@protoc_insertion_point(field_get:ecu.lapi.pb.UdsInterfaceResponse.trans_id)
  return trans_id_;
}
inline void UdsInterfaceResponse::set_trans_id(::google::protobuf::uint64 value) {
  set_has_trans_id();
  trans_id_ = value;
  // @@protoc_insertion_point(field_set:ecu.lapi.pb.UdsInterfaceResponse.trans_id)
}

// optional uint32 source = 3;
inline bool UdsInterfaceResponse::has_source() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UdsInterfaceResponse::set_has_source() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UdsInterfaceResponse::clear_has_source() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UdsInterfaceResponse::clear_source() {
  source_ = 0u;
  clear_has_source();
}
inline ::google::protobuf::uint32 UdsInterfaceResponse::source() const {
  // @@protoc_insertion_point(field_get:ecu.lapi.pb.UdsInterfaceResponse.source)
  return source_;
}
inline void UdsInterfaceResponse::set_source(::google::protobuf::uint32 value) {
  set_has_source();
  source_ = value;
  // @@protoc_insertion_point(field_set:ecu.lapi.pb.UdsInterfaceResponse.source)
}

// optional bytes data = 4;
inline bool UdsInterfaceResponse::has_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UdsInterfaceResponse::set_has_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UdsInterfaceResponse::clear_has_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UdsInterfaceResponse::clear_data() {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& UdsInterfaceResponse::data() const {
  // @@protoc_insertion_point(field_get:ecu.lapi.pb.UdsInterfaceResponse.data)
  return *data_;
}
inline void UdsInterfaceResponse::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set:ecu.lapi.pb.UdsInterfaceResponse.data)
}
inline void UdsInterfaceResponse::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set_char:ecu.lapi.pb.UdsInterfaceResponse.data)
}
inline void UdsInterfaceResponse::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ecu.lapi.pb.UdsInterfaceResponse.data)
}
inline ::std::string* UdsInterfaceResponse::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ecu.lapi.pb.UdsInterfaceResponse.data)
  return data_;
}
inline ::std::string* UdsInterfaceResponse::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UdsInterfaceResponse::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ecu.lapi.pb.UdsInterfaceResponse.data)
}

// -------------------------------------------------------------------

// UdsInterfaceStatus

// optional .ecu.lapi.pb.UdsInterfaceStatus.State state = 1;
inline bool UdsInterfaceStatus::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UdsInterfaceStatus::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UdsInterfaceStatus::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UdsInterfaceStatus::clear_state() {
  state_ = 21;
  clear_has_state();
}
inline ::ecu::lapi::pb::UdsInterfaceStatus_State UdsInterfaceStatus::state() const {
  // @@protoc_insertion_point(field_get:ecu.lapi.pb.UdsInterfaceStatus.state)
  return static_cast< ::ecu::lapi::pb::UdsInterfaceStatus_State >(state_);
}
inline void UdsInterfaceStatus::set_state(::ecu::lapi::pb::UdsInterfaceStatus_State value) {
  assert(::ecu::lapi::pb::UdsInterfaceStatus_State_IsValid(value));
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:ecu.lapi.pb.UdsInterfaceStatus.state)
}

// optional string used_by = 2;
inline bool UdsInterfaceStatus::has_used_by() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UdsInterfaceStatus::set_has_used_by() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UdsInterfaceStatus::clear_has_used_by() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UdsInterfaceStatus::clear_used_by() {
  if (used_by_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    used_by_->clear();
  }
  clear_has_used_by();
}
inline const ::std::string& UdsInterfaceStatus::used_by() const {
  // @@protoc_insertion_point(field_get:ecu.lapi.pb.UdsInterfaceStatus.used_by)
  return *used_by_;
}
inline void UdsInterfaceStatus::set_used_by(const ::std::string& value) {
  set_has_used_by();
  if (used_by_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    used_by_ = new ::std::string;
  }
  used_by_->assign(value);
  // @@protoc_insertion_point(field_set:ecu.lapi.pb.UdsInterfaceStatus.used_by)
}
inline void UdsInterfaceStatus::set_used_by(const char* value) {
  set_has_used_by();
  if (used_by_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    used_by_ = new ::std::string;
  }
  used_by_->assign(value);
  // @@protoc_insertion_point(field_set_char:ecu.lapi.pb.UdsInterfaceStatus.used_by)
}
inline void UdsInterfaceStatus::set_used_by(const char* value, size_t size) {
  set_has_used_by();
  if (used_by_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    used_by_ = new ::std::string;
  }
  used_by_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ecu.lapi.pb.UdsInterfaceStatus.used_by)
}
inline ::std::string* UdsInterfaceStatus::mutable_used_by() {
  set_has_used_by();
  if (used_by_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    used_by_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ecu.lapi.pb.UdsInterfaceStatus.used_by)
  return used_by_;
}
inline ::std::string* UdsInterfaceStatus::release_used_by() {
  clear_has_used_by();
  if (used_by_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = used_by_;
    used_by_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UdsInterfaceStatus::set_allocated_used_by(::std::string* used_by) {
  if (used_by_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete used_by_;
  }
  if (used_by) {
    set_has_used_by();
    used_by_ = used_by;
  } else {
    clear_has_used_by();
    used_by_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ecu.lapi.pb.UdsInterfaceStatus.used_by)
}

// -------------------------------------------------------------------

// UdsIfMessage

// optional .ecu.lapi.pb.UdsInterface interface = 1;
inline bool UdsIfMessage::has_interface() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UdsIfMessage::set_has_interface() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UdsIfMessage::clear_has_interface() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UdsIfMessage::clear_interface() {
  if (interface_ != NULL) interface_->::ecu::lapi::pb::UdsInterface::Clear();
  clear_has_interface();
}
inline const ::ecu::lapi::pb::UdsInterface& UdsIfMessage::interface() const {
  // @@protoc_insertion_point(field_get:ecu.lapi.pb.UdsIfMessage.interface)
  return interface_ != NULL ? *interface_ : *default_instance_->interface_;
}
inline ::ecu::lapi::pb::UdsInterface* UdsIfMessage::mutable_interface() {
  set_has_interface();
  if (interface_ == NULL) interface_ = new ::ecu::lapi::pb::UdsInterface;
  // @@protoc_insertion_point(field_mutable:ecu.lapi.pb.UdsIfMessage.interface)
  return interface_;
}
inline ::ecu::lapi::pb::UdsInterface* UdsIfMessage::release_interface() {
  clear_has_interface();
  ::ecu::lapi::pb::UdsInterface* temp = interface_;
  interface_ = NULL;
  return temp;
}
inline void UdsIfMessage::set_allocated_interface(::ecu::lapi::pb::UdsInterface* interface) {
  delete interface_;
  interface_ = interface;
  if (interface) {
    set_has_interface();
  } else {
    clear_has_interface();
  }
  // @@protoc_insertion_point(field_set_allocated:ecu.lapi.pb.UdsIfMessage.interface)
}

// optional .ecu.lapi.pb.UdsInterfaceAllocation allocation = 2;
inline bool UdsIfMessage::has_allocation() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UdsIfMessage::set_has_allocation() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UdsIfMessage::clear_has_allocation() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UdsIfMessage::clear_allocation() {
  if (allocation_ != NULL) allocation_->::ecu::lapi::pb::UdsInterfaceAllocation::Clear();
  clear_has_allocation();
}
inline const ::ecu::lapi::pb::UdsInterfaceAllocation& UdsIfMessage::allocation() const {
  // @@protoc_insertion_point(field_get:ecu.lapi.pb.UdsIfMessage.allocation)
  return allocation_ != NULL ? *allocation_ : *default_instance_->allocation_;
}
inline ::ecu::lapi::pb::UdsInterfaceAllocation* UdsIfMessage::mutable_allocation() {
  set_has_allocation();
  if (allocation_ == NULL) allocation_ = new ::ecu::lapi::pb::UdsInterfaceAllocation;
  // @@protoc_insertion_point(field_mutable:ecu.lapi.pb.UdsIfMessage.allocation)
  return allocation_;
}
inline ::ecu::lapi::pb::UdsInterfaceAllocation* UdsIfMessage::release_allocation() {
  clear_has_allocation();
  ::ecu::lapi::pb::UdsInterfaceAllocation* temp = allocation_;
  allocation_ = NULL;
  return temp;
}
inline void UdsIfMessage::set_allocated_allocation(::ecu::lapi::pb::UdsInterfaceAllocation* allocation) {
  delete allocation_;
  allocation_ = allocation;
  if (allocation) {
    set_has_allocation();
  } else {
    clear_has_allocation();
  }
  // @@protoc_insertion_point(field_set_allocated:ecu.lapi.pb.UdsIfMessage.allocation)
}

// optional .ecu.lapi.pb.UdsInterfaceRequest request = 3;
inline bool UdsIfMessage::has_request() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UdsIfMessage::set_has_request() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UdsIfMessage::clear_has_request() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UdsIfMessage::clear_request() {
  if (request_ != NULL) request_->::ecu::lapi::pb::UdsInterfaceRequest::Clear();
  clear_has_request();
}
inline const ::ecu::lapi::pb::UdsInterfaceRequest& UdsIfMessage::request() const {
  // @@protoc_insertion_point(field_get:ecu.lapi.pb.UdsIfMessage.request)
  return request_ != NULL ? *request_ : *default_instance_->request_;
}
inline ::ecu::lapi::pb::UdsInterfaceRequest* UdsIfMessage::mutable_request() {
  set_has_request();
  if (request_ == NULL) request_ = new ::ecu::lapi::pb::UdsInterfaceRequest;
  // @@protoc_insertion_point(field_mutable:ecu.lapi.pb.UdsIfMessage.request)
  return request_;
}
inline ::ecu::lapi::pb::UdsInterfaceRequest* UdsIfMessage::release_request() {
  clear_has_request();
  ::ecu::lapi::pb::UdsInterfaceRequest* temp = request_;
  request_ = NULL;
  return temp;
}
inline void UdsIfMessage::set_allocated_request(::ecu::lapi::pb::UdsInterfaceRequest* request) {
  delete request_;
  request_ = request;
  if (request) {
    set_has_request();
  } else {
    clear_has_request();
  }
  // @@protoc_insertion_point(field_set_allocated:ecu.lapi.pb.UdsIfMessage.request)
}

// optional .ecu.lapi.pb.UdsInterfaceResponse response = 4;
inline bool UdsIfMessage::has_response() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UdsIfMessage::set_has_response() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UdsIfMessage::clear_has_response() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UdsIfMessage::clear_response() {
  if (response_ != NULL) response_->::ecu::lapi::pb::UdsInterfaceResponse::Clear();
  clear_has_response();
}
inline const ::ecu::lapi::pb::UdsInterfaceResponse& UdsIfMessage::response() const {
  // @@protoc_insertion_point(field_get:ecu.lapi.pb.UdsIfMessage.response)
  return response_ != NULL ? *response_ : *default_instance_->response_;
}
inline ::ecu::lapi::pb::UdsInterfaceResponse* UdsIfMessage::mutable_response() {
  set_has_response();
  if (response_ == NULL) response_ = new ::ecu::lapi::pb::UdsInterfaceResponse;
  // @@protoc_insertion_point(field_mutable:ecu.lapi.pb.UdsIfMessage.response)
  return response_;
}
inline ::ecu::lapi::pb::UdsInterfaceResponse* UdsIfMessage::release_response() {
  clear_has_response();
  ::ecu::lapi::pb::UdsInterfaceResponse* temp = response_;
  response_ = NULL;
  return temp;
}
inline void UdsIfMessage::set_allocated_response(::ecu::lapi::pb::UdsInterfaceResponse* response) {
  delete response_;
  response_ = response;
  if (response) {
    set_has_response();
  } else {
    clear_has_response();
  }
  // @@protoc_insertion_point(field_set_allocated:ecu.lapi.pb.UdsIfMessage.response)
}

// optional .ecu.lapi.pb.UdsInterfaceStatus status = 5;
inline bool UdsIfMessage::has_status() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UdsIfMessage::set_has_status() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UdsIfMessage::clear_has_status() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UdsIfMessage::clear_status() {
  if (status_ != NULL) status_->::ecu::lapi::pb::UdsInterfaceStatus::Clear();
  clear_has_status();
}
inline const ::ecu::lapi::pb::UdsInterfaceStatus& UdsIfMessage::status() const {
  // @@protoc_insertion_point(field_get:ecu.lapi.pb.UdsIfMessage.status)
  return status_ != NULL ? *status_ : *default_instance_->status_;
}
inline ::ecu::lapi::pb::UdsInterfaceStatus* UdsIfMessage::mutable_status() {
  set_has_status();
  if (status_ == NULL) status_ = new ::ecu::lapi::pb::UdsInterfaceStatus;
  // @@protoc_insertion_point(field_mutable:ecu.lapi.pb.UdsIfMessage.status)
  return status_;
}
inline ::ecu::lapi::pb::UdsInterfaceStatus* UdsIfMessage::release_status() {
  clear_has_status();
  ::ecu::lapi::pb::UdsInterfaceStatus* temp = status_;
  status_ = NULL;
  return temp;
}
inline void UdsIfMessage::set_allocated_status(::ecu::lapi::pb::UdsInterfaceStatus* status) {
  delete status_;
  status_ = status;
  if (status) {
    set_has_status();
  } else {
    clear_has_status();
  }
  // @@protoc_insertion_point(field_set_allocated:ecu.lapi.pb.UdsIfMessage.status)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb
}  // namespace lapi
}  // namespace ecu

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::ecu::lapi::pb::UdsInterface_TransportProtocol> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ecu::lapi::pb::UdsInterface_TransportProtocol>() {
  return ::ecu::lapi::pb::UdsInterface_TransportProtocol_descriptor();
}
template <> struct is_proto_enum< ::ecu::lapi::pb::UdsInterface_PhysicalInterface> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ecu::lapi::pb::UdsInterface_PhysicalInterface>() {
  return ::ecu::lapi::pb::UdsInterface_PhysicalInterface_descriptor();
}
template <> struct is_proto_enum< ::ecu::lapi::pb::UdsInterfaceRequest_FlowStatus> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ecu::lapi::pb::UdsInterfaceRequest_FlowStatus>() {
  return ::ecu::lapi::pb::UdsInterfaceRequest_FlowStatus_descriptor();
}
template <> struct is_proto_enum< ::ecu::lapi::pb::UdsInterfaceResponse_StatusCode> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ecu::lapi::pb::UdsInterfaceResponse_StatusCode>() {
  return ::ecu::lapi::pb::UdsInterfaceResponse_StatusCode_descriptor();
}
template <> struct is_proto_enum< ::ecu::lapi::pb::UdsInterfaceStatus_State> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ecu::lapi::pb::UdsInterfaceStatus_State>() {
  return ::ecu::lapi::pb::UdsInterfaceStatus_State_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_uds_2eproto__INCLUDED
