/****************************************************************************
 *
 * File:
 *     ihcitransport.h (cffcbbf) 2017-05-16 16:50:44 +0000 Erik Berrio
 *     $Product: OpenSynergy Blue SDK v5.x $
 *     Commit: cffcbbf0fd5215f4b9f726f387893882c32cec3e
 *
 * Description:
 *     Definition of an HciTransport interface
 * 
 * Copyright 1999-2017 OpenSynergy GmbH.
 * All rights reserved. All unpublished rights reserved.
 *
 * Unpublished Confidential Information of OpenSynergy GmbH.  
 * Do Not Disclose.
 *
 * No part of this work may be used or reproduced in any form or by any 
 * means, or stored in a database or retrieval system, without prior written 
 * permission of OpenSynergy GmbH.
 * 
 * Use of this work is governed by a license granted by OpenSynergy GmbH. 
 * This work contains confidential and proprietary information of
 * OpenSynergy GmbH. which is protected by copyright, trade secret,
 * trademark and other intellectual property rights.
 *
 ****************************************************************************/

#ifndef __IHCITRANSPORT_H
#define __IHCITRANSPORT_H

#include "bttypes2.h"
#include "hcitrans.h"

/*---------------------------------------------------------------------------
 * HCI Transport Interface component
 *
 *     The IHciTransport interface allows an AmpHciController instance to 
 *     communicate with an actual AMP Controller over its HCI.
 *
 *     To use this class, a platform-specific class must be implemented
 *     to support this interface as documented. Then, a pointer to the
 *     interface is provided as an argument to AHC_Create(), which constructs
 *     a new AmpHciController instance and defines it to use the transport 
 *     provided.
 *
 *     Based on how it is implemented, the HCI Transport may use USB, 
 *     UART, SDIO, or any other mechanism as required to access the HCI
 *     supported by the AMP Controller.
 */


/*---------------------------------------------------------------------------
 * HciTransportEventType type
 *
 *   Defines the type of an HciTransport event.
 */
typedef BtEventTypeEx HciTransportEventType;

/** Initialization of this module is complete and was successful */
#define HCITRANE_INITIALIZED (BTE_TYPE_BASE_HCITRANSPORT + 0x00)

/** This module is deinitialized, either because the user 
 * requested deinit or a transport error occurred. No further events
 * will be delivered until re-initialized. The reason for
 * deinitialization, if any, is delivered in parms->u.error.
 */
#define HCITRANE_DEINITIALIZED (BTE_TYPE_BASE_HCITRANSPORT + 0x01)

/** The transport has initiated transmission of a packet and the 
 * associated data may be released. Packet pointer is found in
 * parms->u.packet. parms->e.status indicates whether the packet was
 * successfully sent. If status is other than BT_STATUS_SUCCESS, it is
 * assumed that all outstanding tx packets are being returned in 
 * anticipation of HCITRANE_DEINITIALIZED.
 */
#define HCITRANE_PACKET_SENT (BTE_TYPE_BASE_HCITRANSPORT + 0x02)

/** Returns a previously supplied rx buffer in parms->u.buffer to the
 * user of this object. If parms->e.status contains BT_STATUS_SUCCESS,
 * the buffer contains data received from the controller. If not,
 * the data in the buffer is invalid and should be ignored.
 */
#define HCITRANE_DATA_IND (BTE_TYPE_BASE_HCITRANSPORT + 0x03)

/** A receive buffer is requested. parms->u.buffer_req.len contains the
 * requested size of the rx buffer and "type" contains the requested buffer
 * type. The handler of this callback is responsible for filling in
 * parms->u.buffer_req.buffer with an allocated buffer if possible.
 *
 * If a buffer is successfully allocated, HCITRANE_DATA_IND must be used
 * to return the allocated buffer to the upper layer that provided it.
 *
 * If a buffer could not be allocated, HciTransport::BufferAvailable()
 * will be later be called when one is available.
 */
#define HCITRANE_BUFFER_REQ (BTE_TYPE_BASE_HCITRANSPORT + 0x04)

/* End of HciTransportEventType type */

/* Forward definition of the HciTransport interface */
typedef struct _IHciTransport IHciTransport;

/*---------------------------------------------------------------------------
 * HciTransportEvent structure
 *
 *     Describes an event generated by the HciTransport. Events of this type
 *     are delivered to the handler registered at init time (see 
 *     HciTransport::Init).
 */
typedef struct _HciTransportEvent {
    /* Inherited event parameters. e.type contains an HciTransportEventType
     * value
     */
    BtEventEx e;    

    /* Group: Only one of the following fields may be valid. */
    union {
        /* Valid during HCITRANE_DEINITIALIZED. */
        HciTransError error; 

        /* Valid during HCITRANE_PACKET_SENT. */
        HciPacket *packet;

        /* Valid during HCITRANE_DATA_IND. */
        HciBuffer *buffer;

        /* Valid during HCITRANE_BUFFER_REQ. */
        struct {
            /* The requested buffer length */
            U16 len;

            /* Requested buffer type */
            HciBufFlags type;

            /* On return, if a buffer was available, buffer is filled */
            HciBuffer *buffer;
        } buffer_req;
    } u;
} HciTransportEvent;


/*---------------------------------------------------------------------------
 * HciTransport::Init()
 *
 *     Requests initialization of a transport.
 *
 * Parameters:
 *     transport - Pointer to an IHciTransport interface in deinit state.
 *
 *     handler - Handler to receive all events related to this transport's
 *         activities.
 *
 * Returns:      
 *     BT_STATUS_SUCCESS - The transport is initialized and ready.
 * 
 *     BT_STATUS_PENDING - Transport initialization has begun and handler
 *         will be signaled with success/failure.
 *
 *     (other) - A failure occurred and initialization will not proceed.
 */
typedef BtStatus (*BtHcitranInit)(IHciTransport *transport, BtHandlerEx *handler);

/*---------------------------------------------------------------------------
 * HciTransport::Deinit()
 *
 *     Requests that the transport be shut down and all internal resources
 *     released.
 *
 * Parameters:
 *     transport - Pointer to an IHciTransport interface.
 *
 * Returns:      
 *     BT_STATUS_SUCCESS - The transport is deinitialized. No other events
 *         will be delivered until and unless the transport is re-
 *         initialized.
 * 
 *     BT_STATUS_PENDING - Transport deinit has begun and handler
 *         will be signaled with success/failure.
 *
 *     (other) - A failure occurred and deinitialization will not proceed.
 */
typedef BtStatus (*BtHcitranDeinit)(IHciTransport *transport);

/*---------------------------------------------------------------------------
 * HciTransport::BufferAvailable()
 *
 *     Indicates to the transport that a buffer may be available. Note that 
 *     this function will only be called once after a failed
 *     HCITRANE_BUFFER_REQ allocation attempt.
 *
 * Parameters:
 *     transport - Pointer to an IHciTransport interface waiting for an rx buffer.
 *
 *     type - Indicates a mask of buffer types that may be available.
 *
 */
typedef BtStatus (*BtHcitranBufferAvailable)(IHciTransport *transport, HciBufFlags type);

/*---------------------------------------------------------------------------
 * HciTransport::SendData()
 *
 *     Requests transmission of an HciPacket to the associated controller.
 *
 * Parameters:
 *     transport - Pointer to an initialized IHciTransport interface.
 *
 *     packet - A packet of data to be delivered. If accepted, this packet
 *         must later be indicated as complete with HCITRANE_PACKET_SENT
 *
 * Returns:      
 *     BT_STATUS_PENDING - The transport will begin sending this packet.
 * 
 *     (other) - The transport cannot accept this packet.
 */
typedef BtStatus (*BtHcitranSendData)(IHciTransport *transport, HciPacket *packet);


/*---------------------------------------------------------------------------
 * HciTransport::Pause()
 *
 *     Suspends execution of the transport for a very brief period.
 *     The transport must guarantee that no callbacks are sent from the
 *     time Pause() is called until the time Resume() is called. Pause() and
 *     Resume must not be called during a callback, and must not be called
 *     recursively. Every call to Pause() will be followed by a single call to 
 *     Resume().
 *
 * Parameters:
 *     transport - Pointer to an initialized IHciTransport interface.
 */
typedef void (*BtHcitranPause)(IHciTransport *transport);

/*---------------------------------------------------------------------------
 * HciTransport::Resume()
 *
 *     Permits ordinary execution of the transport after a call
 *     to Pause().
 *
 * Parameters:
 *     transport - Pointer to an initialized IHciTransport interface.
 */
typedef void (*BtHcitranResume)(IHciTransport *transport);


/*---------------------------------------------------------------------------
 * IHciTransport structure
 *
 *     Defines the interface between a transport and a user of the transport.
 *
 *     Note: all functions will receive a pointer to this structure,
 *     so any class implementing this interface must either place this
 *     structure as its first member, or use ContainingRecord to locate
 *     the actual context pointer.
 */
struct _IHciTransport
{
    BtHcitranInit            init;
    BtHcitranDeinit          deinit;
    BtHcitranBufferAvailable bufferAvailable;
    BtHcitranSendData        sendData;
    BtHcitranPause           pause;
    BtHcitranResume          resume;
};


/* Convenience prototypes & macros for access members of the interface */
BtStatus HCIT_Init(IHciTransport *transport, BtHandlerEx *handler);
#define HCIT_Init(transport, handler) transport->init(transport, handler)
BtStatus HCIT_Deinit(IHciTransport *transport);
#define HCIT_Deinit(transport) transport->deinit(transport)
void HCIT_BufferAvailable(IHciTransport *transport, HciBufFlags type);
#define HCIT_BufferAvailable(transport, type) transport->bufferAvailable(transport, type)
BtStatus HCIT_SendData(IHciTransport *transport, HciPacket *packet);
#define HCIT_SendData(transport, packet) transport->sendData(transport, packet)
BtStatus HCIT_Pause(IHciTransport *transport);
#define HCIT_Pause(transport) transport->pause(transport)
BtStatus HCIT_Resume(IHciTransport *transport);
#define HCIT_Resume(transport) transport->resume(transport)

#endif /* __IHCITRANSPORT_H */
